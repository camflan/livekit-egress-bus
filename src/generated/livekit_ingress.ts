// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v4.25.6
// source: livekit_ingress.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { FileDescriptorProto as FileDescriptorProto1 } from "ts-proto-descriptors";
import {
  AudioCodec,
  audioCodecFromJSON,
  audioCodecToJSON,
  protoMetadata as protoMetadata1,
  TrackInfo,
  TrackSource,
  trackSourceFromJSON,
  trackSourceToJSON,
  VideoCodec,
  videoCodecFromJSON,
  videoCodecToJSON,
  VideoLayer,
} from "./livekit_models";
import { messageTypeRegistry } from "./typeRegistry";

export const protobufPackage = "livekit";

export const IngressInput = {
  RTMP_INPUT: 0,
  WHIP_INPUT: 1,
  /** URL_INPUT - Pull from the provided URL. Only HTTP url are supported, serving either a single media file or a HLS stream */
  URL_INPUT: 2,
  UNRECOGNIZED: -1,
} as const;

export type IngressInput = (typeof IngressInput)[keyof typeof IngressInput];

export namespace IngressInput {
  export type RTMP_INPUT = typeof IngressInput.RTMP_INPUT;
  export type WHIP_INPUT = typeof IngressInput.WHIP_INPUT;
  export type URL_INPUT = typeof IngressInput.URL_INPUT;
  export type UNRECOGNIZED = typeof IngressInput.UNRECOGNIZED;
}

export function ingressInputFromJSON(object: any): IngressInput {
  switch (object) {
    case 0:
    case "RTMP_INPUT":
      return IngressInput.RTMP_INPUT;
    case 1:
    case "WHIP_INPUT":
      return IngressInput.WHIP_INPUT;
    case 2:
    case "URL_INPUT":
      return IngressInput.URL_INPUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IngressInput.UNRECOGNIZED;
  }
}

export function ingressInputToJSON(object: IngressInput): string {
  switch (object) {
    case IngressInput.RTMP_INPUT:
      return "RTMP_INPUT";
    case IngressInput.WHIP_INPUT:
      return "WHIP_INPUT";
    case IngressInput.URL_INPUT:
      return "URL_INPUT";
    case IngressInput.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const IngressAudioEncodingPreset = {
  /** OPUS_STEREO_96KBPS - OPUS, 2 channels, 96kbps */
  OPUS_STEREO_96KBPS: 0,
  /** OPUS_MONO_64KBS - OPUS, 1 channel, 64kbps */
  OPUS_MONO_64KBS: 1,
  UNRECOGNIZED: -1,
} as const;

export type IngressAudioEncodingPreset =
  (typeof IngressAudioEncodingPreset)[keyof typeof IngressAudioEncodingPreset];

export namespace IngressAudioEncodingPreset {
  export type OPUS_STEREO_96KBPS =
    typeof IngressAudioEncodingPreset.OPUS_STEREO_96KBPS;
  export type OPUS_MONO_64KBS =
    typeof IngressAudioEncodingPreset.OPUS_MONO_64KBS;
  export type UNRECOGNIZED = typeof IngressAudioEncodingPreset.UNRECOGNIZED;
}

export function ingressAudioEncodingPresetFromJSON(
  object: any,
): IngressAudioEncodingPreset {
  switch (object) {
    case 0:
    case "OPUS_STEREO_96KBPS":
      return IngressAudioEncodingPreset.OPUS_STEREO_96KBPS;
    case 1:
    case "OPUS_MONO_64KBS":
      return IngressAudioEncodingPreset.OPUS_MONO_64KBS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IngressAudioEncodingPreset.UNRECOGNIZED;
  }
}

export function ingressAudioEncodingPresetToJSON(
  object: IngressAudioEncodingPreset,
): string {
  switch (object) {
    case IngressAudioEncodingPreset.OPUS_STEREO_96KBPS:
      return "OPUS_STEREO_96KBPS";
    case IngressAudioEncodingPreset.OPUS_MONO_64KBS:
      return "OPUS_MONO_64KBS";
    case IngressAudioEncodingPreset.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const IngressVideoEncodingPreset = {
  /** H264_720P_30FPS_3_LAYERS - 1280x720,  30fps, 1900kbps main layer, 3 layers total */
  H264_720P_30FPS_3_LAYERS: 0,
  /** H264_1080P_30FPS_3_LAYERS - 1980x1080, 30fps, 3500kbps main layer, 3 layers total */
  H264_1080P_30FPS_3_LAYERS: 1,
  /** H264_540P_25FPS_2_LAYERS - 960x540,  25fps, 1000kbps  main layer, 2 layers total */
  H264_540P_25FPS_2_LAYERS: 2,
  /** H264_720P_30FPS_1_LAYER - 1280x720,  30fps, 1900kbps, no simulcast */
  H264_720P_30FPS_1_LAYER: 3,
  /** H264_1080P_30FPS_1_LAYER - 1980x1080, 30fps, 3500kbps, no simulcast */
  H264_1080P_30FPS_1_LAYER: 4,
  /** H264_720P_30FPS_3_LAYERS_HIGH_MOTION - 1280x720,  30fps, 2500kbps main layer, 3 layers total, higher bitrate for high motion, harder to encode content */
  H264_720P_30FPS_3_LAYERS_HIGH_MOTION: 5,
  /** H264_1080P_30FPS_3_LAYERS_HIGH_MOTION - 1980x1080, 30fps, 4500kbps main layer, 3 layers total, higher bitrate for high motion, harder to encode content */
  H264_1080P_30FPS_3_LAYERS_HIGH_MOTION: 6,
  /** H264_540P_25FPS_2_LAYERS_HIGH_MOTION - 960x540,  25fps, 1300kbps  main layer, 2 layers total, higher bitrate for high motion, harder to encode content */
  H264_540P_25FPS_2_LAYERS_HIGH_MOTION: 7,
  /** H264_720P_30FPS_1_LAYER_HIGH_MOTION - 1280x720,  30fps, 2500kbps, no simulcast, higher bitrate for high motion, harder to encode content */
  H264_720P_30FPS_1_LAYER_HIGH_MOTION: 8,
  /** H264_1080P_30FPS_1_LAYER_HIGH_MOTION - 1980x1080, 30fps, 4500kbps, no simulcast, higher bitrate for high motion, harder to encode content */
  H264_1080P_30FPS_1_LAYER_HIGH_MOTION: 9,
  UNRECOGNIZED: -1,
} as const;

export type IngressVideoEncodingPreset =
  (typeof IngressVideoEncodingPreset)[keyof typeof IngressVideoEncodingPreset];

export namespace IngressVideoEncodingPreset {
  export type H264_720P_30FPS_3_LAYERS =
    typeof IngressVideoEncodingPreset.H264_720P_30FPS_3_LAYERS;
  export type H264_1080P_30FPS_3_LAYERS =
    typeof IngressVideoEncodingPreset.H264_1080P_30FPS_3_LAYERS;
  export type H264_540P_25FPS_2_LAYERS =
    typeof IngressVideoEncodingPreset.H264_540P_25FPS_2_LAYERS;
  export type H264_720P_30FPS_1_LAYER =
    typeof IngressVideoEncodingPreset.H264_720P_30FPS_1_LAYER;
  export type H264_1080P_30FPS_1_LAYER =
    typeof IngressVideoEncodingPreset.H264_1080P_30FPS_1_LAYER;
  export type H264_720P_30FPS_3_LAYERS_HIGH_MOTION =
    typeof IngressVideoEncodingPreset.H264_720P_30FPS_3_LAYERS_HIGH_MOTION;
  export type H264_1080P_30FPS_3_LAYERS_HIGH_MOTION =
    typeof IngressVideoEncodingPreset.H264_1080P_30FPS_3_LAYERS_HIGH_MOTION;
  export type H264_540P_25FPS_2_LAYERS_HIGH_MOTION =
    typeof IngressVideoEncodingPreset.H264_540P_25FPS_2_LAYERS_HIGH_MOTION;
  export type H264_720P_30FPS_1_LAYER_HIGH_MOTION =
    typeof IngressVideoEncodingPreset.H264_720P_30FPS_1_LAYER_HIGH_MOTION;
  export type H264_1080P_30FPS_1_LAYER_HIGH_MOTION =
    typeof IngressVideoEncodingPreset.H264_1080P_30FPS_1_LAYER_HIGH_MOTION;
  export type UNRECOGNIZED = typeof IngressVideoEncodingPreset.UNRECOGNIZED;
}

export function ingressVideoEncodingPresetFromJSON(
  object: any,
): IngressVideoEncodingPreset {
  switch (object) {
    case 0:
    case "H264_720P_30FPS_3_LAYERS":
      return IngressVideoEncodingPreset.H264_720P_30FPS_3_LAYERS;
    case 1:
    case "H264_1080P_30FPS_3_LAYERS":
      return IngressVideoEncodingPreset.H264_1080P_30FPS_3_LAYERS;
    case 2:
    case "H264_540P_25FPS_2_LAYERS":
      return IngressVideoEncodingPreset.H264_540P_25FPS_2_LAYERS;
    case 3:
    case "H264_720P_30FPS_1_LAYER":
      return IngressVideoEncodingPreset.H264_720P_30FPS_1_LAYER;
    case 4:
    case "H264_1080P_30FPS_1_LAYER":
      return IngressVideoEncodingPreset.H264_1080P_30FPS_1_LAYER;
    case 5:
    case "H264_720P_30FPS_3_LAYERS_HIGH_MOTION":
      return IngressVideoEncodingPreset.H264_720P_30FPS_3_LAYERS_HIGH_MOTION;
    case 6:
    case "H264_1080P_30FPS_3_LAYERS_HIGH_MOTION":
      return IngressVideoEncodingPreset.H264_1080P_30FPS_3_LAYERS_HIGH_MOTION;
    case 7:
    case "H264_540P_25FPS_2_LAYERS_HIGH_MOTION":
      return IngressVideoEncodingPreset.H264_540P_25FPS_2_LAYERS_HIGH_MOTION;
    case 8:
    case "H264_720P_30FPS_1_LAYER_HIGH_MOTION":
      return IngressVideoEncodingPreset.H264_720P_30FPS_1_LAYER_HIGH_MOTION;
    case 9:
    case "H264_1080P_30FPS_1_LAYER_HIGH_MOTION":
      return IngressVideoEncodingPreset.H264_1080P_30FPS_1_LAYER_HIGH_MOTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IngressVideoEncodingPreset.UNRECOGNIZED;
  }
}

export function ingressVideoEncodingPresetToJSON(
  object: IngressVideoEncodingPreset,
): string {
  switch (object) {
    case IngressVideoEncodingPreset.H264_720P_30FPS_3_LAYERS:
      return "H264_720P_30FPS_3_LAYERS";
    case IngressVideoEncodingPreset.H264_1080P_30FPS_3_LAYERS:
      return "H264_1080P_30FPS_3_LAYERS";
    case IngressVideoEncodingPreset.H264_540P_25FPS_2_LAYERS:
      return "H264_540P_25FPS_2_LAYERS";
    case IngressVideoEncodingPreset.H264_720P_30FPS_1_LAYER:
      return "H264_720P_30FPS_1_LAYER";
    case IngressVideoEncodingPreset.H264_1080P_30FPS_1_LAYER:
      return "H264_1080P_30FPS_1_LAYER";
    case IngressVideoEncodingPreset.H264_720P_30FPS_3_LAYERS_HIGH_MOTION:
      return "H264_720P_30FPS_3_LAYERS_HIGH_MOTION";
    case IngressVideoEncodingPreset.H264_1080P_30FPS_3_LAYERS_HIGH_MOTION:
      return "H264_1080P_30FPS_3_LAYERS_HIGH_MOTION";
    case IngressVideoEncodingPreset.H264_540P_25FPS_2_LAYERS_HIGH_MOTION:
      return "H264_540P_25FPS_2_LAYERS_HIGH_MOTION";
    case IngressVideoEncodingPreset.H264_720P_30FPS_1_LAYER_HIGH_MOTION:
      return "H264_720P_30FPS_1_LAYER_HIGH_MOTION";
    case IngressVideoEncodingPreset.H264_1080P_30FPS_1_LAYER_HIGH_MOTION:
      return "H264_1080P_30FPS_1_LAYER_HIGH_MOTION";
    case IngressVideoEncodingPreset.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreateIngressRequest {
  $type: "livekit.CreateIngressRequest";
  inputType: IngressInput;
  /** Where to pull media from, only for URL input type */
  url: string;
  /** User provided identifier for the ingress */
  name: string;
  /** room to publish to */
  roomName: string;
  /** publish as participant */
  participantIdentity: string;
  /** name of publishing participant (used for display only) */
  participantName: string;
  /** metadata associated with the publishing participant */
  participantMetadata: string;
  /**
   * [depreacted ] whether to pass through the incoming media without transcoding, only compatible with some input types. Use `enable_transcoding` instead.
   *
   * @deprecated
   */
  bypassTranscoding: boolean;
  /** Whether to transcode the ingested media. Only WHIP supports disabling transcoding currently. WHIP will default to transcoding disabled. Replaces `bypass_transcoding. */
  enableTranscoding?: boolean | undefined;
  audio: IngressAudioOptions | undefined;
  video: IngressVideoOptions | undefined;
  /** The default value is true and when set to false, the new connection attempts will be rejected */
  enabled?: boolean | undefined;
}

export interface IngressAudioOptions {
  $type: "livekit.IngressAudioOptions";
  name: string;
  source: TrackSource;
  preset?: IngressAudioEncodingPreset | undefined;
  options?: IngressAudioEncodingOptions | undefined;
}

export interface IngressVideoOptions {
  $type: "livekit.IngressVideoOptions";
  name: string;
  source: TrackSource;
  preset?: IngressVideoEncodingPreset | undefined;
  options?: IngressVideoEncodingOptions | undefined;
}

export interface IngressAudioEncodingOptions {
  $type: "livekit.IngressAudioEncodingOptions";
  /** desired audio codec to publish to room */
  audioCodec: AudioCodec;
  bitrate: number;
  disableDtx: boolean;
  channels: number;
}

export interface IngressVideoEncodingOptions {
  $type: "livekit.IngressVideoEncodingOptions";
  /** desired codec to publish to room */
  videoCodec: VideoCodec;
  frameRate: number;
  /** simulcast layers to publish, when empty, should usually be set to layers at 1/2 and 1/4 of the dimensions */
  layers: VideoLayer[];
}

export interface IngressInfo {
  $type: "livekit.IngressInfo";
  ingressId: string;
  name: string;
  streamKey: string;
  /** URL to point the encoder to for push (RTMP, WHIP), or location to pull media from for pull (URL) */
  url: string;
  /**
   * for RTMP input, it'll be a rtmp:// URL
   * for FILE input, it'll be a http:// URL
   * for SRT input, it'll be a srt:// URL
   */
  inputType: IngressInput;
  /** @deprecated */
  bypassTranscoding: boolean;
  enableTranscoding?: boolean | undefined;
  audio: IngressAudioOptions | undefined;
  video: IngressVideoOptions | undefined;
  roomName: string;
  participantIdentity: string;
  participantName: string;
  participantMetadata: string;
  reusable: boolean;
  /** Description of error/stream non compliance and debug info for publisher otherwise (received bitrate, resolution, bandwidth) */
  state: IngressState | undefined;
  /** The default value is true and when set to false, the new connection attempts will be rejected */
  enabled?: boolean | undefined;
}

export interface IngressState {
  $type: "livekit.IngressState";
  status: IngressState_Status;
  /** Error/non compliance description if any */
  error: string;
  video: InputVideoState | undefined;
  audio: InputAudioState | undefined;
  /** ID of the current/previous room published to */
  roomId: string;
  startedAt: bigint;
  endedAt: bigint;
  updatedAt: bigint;
  resourceId: string;
  tracks: TrackInfo[];
}

export const IngressState_Status = {
  ENDPOINT_INACTIVE: 0,
  ENDPOINT_BUFFERING: 1,
  ENDPOINT_PUBLISHING: 2,
  ENDPOINT_ERROR: 3,
  ENDPOINT_COMPLETE: 4,
  UNRECOGNIZED: -1,
} as const;

export type IngressState_Status =
  (typeof IngressState_Status)[keyof typeof IngressState_Status];

export namespace IngressState_Status {
  export type ENDPOINT_INACTIVE = typeof IngressState_Status.ENDPOINT_INACTIVE;
  export type ENDPOINT_BUFFERING =
    typeof IngressState_Status.ENDPOINT_BUFFERING;
  export type ENDPOINT_PUBLISHING =
    typeof IngressState_Status.ENDPOINT_PUBLISHING;
  export type ENDPOINT_ERROR = typeof IngressState_Status.ENDPOINT_ERROR;
  export type ENDPOINT_COMPLETE = typeof IngressState_Status.ENDPOINT_COMPLETE;
  export type UNRECOGNIZED = typeof IngressState_Status.UNRECOGNIZED;
}

export function ingressState_StatusFromJSON(object: any): IngressState_Status {
  switch (object) {
    case 0:
    case "ENDPOINT_INACTIVE":
      return IngressState_Status.ENDPOINT_INACTIVE;
    case 1:
    case "ENDPOINT_BUFFERING":
      return IngressState_Status.ENDPOINT_BUFFERING;
    case 2:
    case "ENDPOINT_PUBLISHING":
      return IngressState_Status.ENDPOINT_PUBLISHING;
    case 3:
    case "ENDPOINT_ERROR":
      return IngressState_Status.ENDPOINT_ERROR;
    case 4:
    case "ENDPOINT_COMPLETE":
      return IngressState_Status.ENDPOINT_COMPLETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IngressState_Status.UNRECOGNIZED;
  }
}

export function ingressState_StatusToJSON(object: IngressState_Status): string {
  switch (object) {
    case IngressState_Status.ENDPOINT_INACTIVE:
      return "ENDPOINT_INACTIVE";
    case IngressState_Status.ENDPOINT_BUFFERING:
      return "ENDPOINT_BUFFERING";
    case IngressState_Status.ENDPOINT_PUBLISHING:
      return "ENDPOINT_PUBLISHING";
    case IngressState_Status.ENDPOINT_ERROR:
      return "ENDPOINT_ERROR";
    case IngressState_Status.ENDPOINT_COMPLETE:
      return "ENDPOINT_COMPLETE";
    case IngressState_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface InputVideoState {
  $type: "livekit.InputVideoState";
  mimeType: string;
  averageBitrate: number;
  width: number;
  height: number;
  framerate: number;
}

export interface InputAudioState {
  $type: "livekit.InputAudioState";
  mimeType: string;
  averageBitrate: number;
  channels: number;
  sampleRate: number;
}

export interface UpdateIngressRequest {
  $type: "livekit.UpdateIngressRequest";
  ingressId: string;
  name: string;
  roomName: string;
  participantIdentity: string;
  participantName: string;
  participantMetadata: string;
  /** @deprecated */
  bypassTranscoding?: boolean | undefined;
  enableTranscoding?: boolean | undefined;
  audio: IngressAudioOptions | undefined;
  video: IngressVideoOptions | undefined;
  /** The default value is true and when set to false, the new connection attempts will be rejected */
  enabled?: boolean | undefined;
}

export interface ListIngressRequest {
  $type: "livekit.ListIngressRequest";
  /** when blank, lists all ingress endpoints */
  roomName: string;
  /** (optional, filter by ingress ID) */
  ingressId: string;
}

export interface ListIngressResponse {
  $type: "livekit.ListIngressResponse";
  items: IngressInfo[];
}

export interface DeleteIngressRequest {
  $type: "livekit.DeleteIngressRequest";
  ingressId: string;
}

function createBaseCreateIngressRequest(): CreateIngressRequest {
  return {
    $type: "livekit.CreateIngressRequest",
    inputType: 0,
    url: "",
    name: "",
    roomName: "",
    participantIdentity: "",
    participantName: "",
    participantMetadata: "",
    bypassTranscoding: false,
    enableTranscoding: undefined,
    audio: undefined,
    video: undefined,
    enabled: undefined,
  };
}

export const CreateIngressRequest: MessageFns<
  CreateIngressRequest,
  "livekit.CreateIngressRequest"
> = {
  $type: "livekit.CreateIngressRequest" as const,

  encode(
    message: CreateIngressRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.inputType !== 0) {
      writer.uint32(8).int32(message.inputType);
    }
    if (message.url !== "") {
      writer.uint32(74).string(message.url);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.roomName !== "") {
      writer.uint32(26).string(message.roomName);
    }
    if (message.participantIdentity !== "") {
      writer.uint32(34).string(message.participantIdentity);
    }
    if (message.participantName !== "") {
      writer.uint32(42).string(message.participantName);
    }
    if (message.participantMetadata !== "") {
      writer.uint32(82).string(message.participantMetadata);
    }
    if (message.bypassTranscoding !== false) {
      writer.uint32(64).bool(message.bypassTranscoding);
    }
    if (message.enableTranscoding !== undefined) {
      writer.uint32(88).bool(message.enableTranscoding);
    }
    if (message.audio !== undefined) {
      IngressAudioOptions.encode(
        message.audio,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.video !== undefined) {
      IngressVideoOptions.encode(
        message.video,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.enabled !== undefined) {
      writer.uint32(96).bool(message.enabled);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateIngressRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIngressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inputType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.roomName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.participantIdentity = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.participantName = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.participantMetadata = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.bypassTranscoding = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.enableTranscoding = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.audio = IngressAudioOptions.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.video = IngressVideoOptions.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIngressRequest {
    return {
      $type: CreateIngressRequest.$type,
      inputType: isSet(object.inputType)
        ? ingressInputFromJSON(object.inputType)
        : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      roomName: isSet(object.roomName)
        ? globalThis.String(object.roomName)
        : "",
      participantIdentity: isSet(object.participantIdentity)
        ? globalThis.String(object.participantIdentity)
        : "",
      participantName: isSet(object.participantName)
        ? globalThis.String(object.participantName)
        : "",
      participantMetadata: isSet(object.participantMetadata)
        ? globalThis.String(object.participantMetadata)
        : "",
      bypassTranscoding: isSet(object.bypassTranscoding)
        ? globalThis.Boolean(object.bypassTranscoding)
        : false,
      enableTranscoding: isSet(object.enableTranscoding)
        ? globalThis.Boolean(object.enableTranscoding)
        : undefined,
      audio: isSet(object.audio)
        ? IngressAudioOptions.fromJSON(object.audio)
        : undefined,
      video: isSet(object.video)
        ? IngressVideoOptions.fromJSON(object.video)
        : undefined,
      enabled: isSet(object.enabled)
        ? globalThis.Boolean(object.enabled)
        : undefined,
    };
  },

  toJSON(message: CreateIngressRequest): unknown {
    const obj: any = {};
    if (message.inputType !== 0) {
      obj.inputType = ingressInputToJSON(message.inputType);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.roomName !== "") {
      obj.roomName = message.roomName;
    }
    if (message.participantIdentity !== "") {
      obj.participantIdentity = message.participantIdentity;
    }
    if (message.participantName !== "") {
      obj.participantName = message.participantName;
    }
    if (message.participantMetadata !== "") {
      obj.participantMetadata = message.participantMetadata;
    }
    if (message.bypassTranscoding !== false) {
      obj.bypassTranscoding = message.bypassTranscoding;
    }
    if (message.enableTranscoding !== undefined) {
      obj.enableTranscoding = message.enableTranscoding;
    }
    if (message.audio !== undefined) {
      obj.audio = IngressAudioOptions.toJSON(message.audio);
    }
    if (message.video !== undefined) {
      obj.video = IngressVideoOptions.toJSON(message.video);
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateIngressRequest>, I>>(
    base?: I,
  ): CreateIngressRequest {
    return CreateIngressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateIngressRequest>, I>>(
    object: I,
  ): CreateIngressRequest {
    const message = createBaseCreateIngressRequest();
    message.inputType = object.inputType ?? 0;
    message.url = object.url ?? "";
    message.name = object.name ?? "";
    message.roomName = object.roomName ?? "";
    message.participantIdentity = object.participantIdentity ?? "";
    message.participantName = object.participantName ?? "";
    message.participantMetadata = object.participantMetadata ?? "";
    message.bypassTranscoding = object.bypassTranscoding ?? false;
    message.enableTranscoding = object.enableTranscoding ?? undefined;
    message.audio =
      object.audio !== undefined && object.audio !== null
        ? IngressAudioOptions.fromPartial(object.audio)
        : undefined;
    message.video =
      object.video !== undefined && object.video !== null
        ? IngressVideoOptions.fromPartial(object.video)
        : undefined;
    message.enabled = object.enabled ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CreateIngressRequest.$type, CreateIngressRequest);

function createBaseIngressAudioOptions(): IngressAudioOptions {
  return {
    $type: "livekit.IngressAudioOptions",
    name: "",
    source: 0,
    preset: undefined,
    options: undefined,
  };
}

export const IngressAudioOptions: MessageFns<
  IngressAudioOptions,
  "livekit.IngressAudioOptions"
> = {
  $type: "livekit.IngressAudioOptions" as const,

  encode(
    message: IngressAudioOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.source !== 0) {
      writer.uint32(16).int32(message.source);
    }
    if (message.preset !== undefined) {
      writer.uint32(24).int32(message.preset);
    }
    if (message.options !== undefined) {
      IngressAudioEncodingOptions.encode(
        message.options,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): IngressAudioOptions {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngressAudioOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.preset = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.options = IngressAudioEncodingOptions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngressAudioOptions {
    return {
      $type: IngressAudioOptions.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      source: isSet(object.source) ? trackSourceFromJSON(object.source) : 0,
      preset: isSet(object.preset)
        ? ingressAudioEncodingPresetFromJSON(object.preset)
        : undefined,
      options: isSet(object.options)
        ? IngressAudioEncodingOptions.fromJSON(object.options)
        : undefined,
    };
  },

  toJSON(message: IngressAudioOptions): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.source !== 0) {
      obj.source = trackSourceToJSON(message.source);
    }
    if (message.preset !== undefined) {
      obj.preset = ingressAudioEncodingPresetToJSON(message.preset);
    }
    if (message.options !== undefined) {
      obj.options = IngressAudioEncodingOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IngressAudioOptions>, I>>(
    base?: I,
  ): IngressAudioOptions {
    return IngressAudioOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IngressAudioOptions>, I>>(
    object: I,
  ): IngressAudioOptions {
    const message = createBaseIngressAudioOptions();
    message.name = object.name ?? "";
    message.source = object.source ?? 0;
    message.preset = object.preset ?? undefined;
    message.options =
      object.options !== undefined && object.options !== null
        ? IngressAudioEncodingOptions.fromPartial(object.options)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(IngressAudioOptions.$type, IngressAudioOptions);

function createBaseIngressVideoOptions(): IngressVideoOptions {
  return {
    $type: "livekit.IngressVideoOptions",
    name: "",
    source: 0,
    preset: undefined,
    options: undefined,
  };
}

export const IngressVideoOptions: MessageFns<
  IngressVideoOptions,
  "livekit.IngressVideoOptions"
> = {
  $type: "livekit.IngressVideoOptions" as const,

  encode(
    message: IngressVideoOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.source !== 0) {
      writer.uint32(16).int32(message.source);
    }
    if (message.preset !== undefined) {
      writer.uint32(24).int32(message.preset);
    }
    if (message.options !== undefined) {
      IngressVideoEncodingOptions.encode(
        message.options,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): IngressVideoOptions {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngressVideoOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.preset = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.options = IngressVideoEncodingOptions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngressVideoOptions {
    return {
      $type: IngressVideoOptions.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      source: isSet(object.source) ? trackSourceFromJSON(object.source) : 0,
      preset: isSet(object.preset)
        ? ingressVideoEncodingPresetFromJSON(object.preset)
        : undefined,
      options: isSet(object.options)
        ? IngressVideoEncodingOptions.fromJSON(object.options)
        : undefined,
    };
  },

  toJSON(message: IngressVideoOptions): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.source !== 0) {
      obj.source = trackSourceToJSON(message.source);
    }
    if (message.preset !== undefined) {
      obj.preset = ingressVideoEncodingPresetToJSON(message.preset);
    }
    if (message.options !== undefined) {
      obj.options = IngressVideoEncodingOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IngressVideoOptions>, I>>(
    base?: I,
  ): IngressVideoOptions {
    return IngressVideoOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IngressVideoOptions>, I>>(
    object: I,
  ): IngressVideoOptions {
    const message = createBaseIngressVideoOptions();
    message.name = object.name ?? "";
    message.source = object.source ?? 0;
    message.preset = object.preset ?? undefined;
    message.options =
      object.options !== undefined && object.options !== null
        ? IngressVideoEncodingOptions.fromPartial(object.options)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(IngressVideoOptions.$type, IngressVideoOptions);

function createBaseIngressAudioEncodingOptions(): IngressAudioEncodingOptions {
  return {
    $type: "livekit.IngressAudioEncodingOptions",
    audioCodec: 0,
    bitrate: 0,
    disableDtx: false,
    channels: 0,
  };
}

export const IngressAudioEncodingOptions: MessageFns<
  IngressAudioEncodingOptions,
  "livekit.IngressAudioEncodingOptions"
> = {
  $type: "livekit.IngressAudioEncodingOptions" as const,

  encode(
    message: IngressAudioEncodingOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.audioCodec !== 0) {
      writer.uint32(8).int32(message.audioCodec);
    }
    if (message.bitrate !== 0) {
      writer.uint32(16).uint32(message.bitrate);
    }
    if (message.disableDtx !== false) {
      writer.uint32(24).bool(message.disableDtx);
    }
    if (message.channels !== 0) {
      writer.uint32(32).uint32(message.channels);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): IngressAudioEncodingOptions {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngressAudioEncodingOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.audioCodec = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bitrate = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disableDtx = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.channels = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngressAudioEncodingOptions {
    return {
      $type: IngressAudioEncodingOptions.$type,
      audioCodec: isSet(object.audioCodec)
        ? audioCodecFromJSON(object.audioCodec)
        : 0,
      bitrate: isSet(object.bitrate) ? globalThis.Number(object.bitrate) : 0,
      disableDtx: isSet(object.disableDtx)
        ? globalThis.Boolean(object.disableDtx)
        : false,
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
    };
  },

  toJSON(message: IngressAudioEncodingOptions): unknown {
    const obj: any = {};
    if (message.audioCodec !== 0) {
      obj.audioCodec = audioCodecToJSON(message.audioCodec);
    }
    if (message.bitrate !== 0) {
      obj.bitrate = Math.round(message.bitrate);
    }
    if (message.disableDtx !== false) {
      obj.disableDtx = message.disableDtx;
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IngressAudioEncodingOptions>, I>>(
    base?: I,
  ): IngressAudioEncodingOptions {
    return IngressAudioEncodingOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IngressAudioEncodingOptions>, I>>(
    object: I,
  ): IngressAudioEncodingOptions {
    const message = createBaseIngressAudioEncodingOptions();
    message.audioCodec = object.audioCodec ?? 0;
    message.bitrate = object.bitrate ?? 0;
    message.disableDtx = object.disableDtx ?? false;
    message.channels = object.channels ?? 0;
    return message;
  },
};

messageTypeRegistry.set(
  IngressAudioEncodingOptions.$type,
  IngressAudioEncodingOptions,
);

function createBaseIngressVideoEncodingOptions(): IngressVideoEncodingOptions {
  return {
    $type: "livekit.IngressVideoEncodingOptions",
    videoCodec: 0,
    frameRate: 0,
    layers: [],
  };
}

export const IngressVideoEncodingOptions: MessageFns<
  IngressVideoEncodingOptions,
  "livekit.IngressVideoEncodingOptions"
> = {
  $type: "livekit.IngressVideoEncodingOptions" as const,

  encode(
    message: IngressVideoEncodingOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.videoCodec !== 0) {
      writer.uint32(8).int32(message.videoCodec);
    }
    if (message.frameRate !== 0) {
      writer.uint32(17).double(message.frameRate);
    }
    for (const v of message.layers) {
      VideoLayer.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): IngressVideoEncodingOptions {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngressVideoEncodingOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.videoCodec = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.frameRate = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.layers.push(VideoLayer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngressVideoEncodingOptions {
    return {
      $type: IngressVideoEncodingOptions.$type,
      videoCodec: isSet(object.videoCodec)
        ? videoCodecFromJSON(object.videoCodec)
        : 0,
      frameRate: isSet(object.frameRate)
        ? globalThis.Number(object.frameRate)
        : 0,
      layers: globalThis.Array.isArray(object?.layers)
        ? object.layers.map((e: any) => VideoLayer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IngressVideoEncodingOptions): unknown {
    const obj: any = {};
    if (message.videoCodec !== 0) {
      obj.videoCodec = videoCodecToJSON(message.videoCodec);
    }
    if (message.frameRate !== 0) {
      obj.frameRate = message.frameRate;
    }
    if (message.layers?.length) {
      obj.layers = message.layers.map((e) => VideoLayer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IngressVideoEncodingOptions>, I>>(
    base?: I,
  ): IngressVideoEncodingOptions {
    return IngressVideoEncodingOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IngressVideoEncodingOptions>, I>>(
    object: I,
  ): IngressVideoEncodingOptions {
    const message = createBaseIngressVideoEncodingOptions();
    message.videoCodec = object.videoCodec ?? 0;
    message.frameRate = object.frameRate ?? 0;
    message.layers = object.layers?.map((e) => VideoLayer.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(
  IngressVideoEncodingOptions.$type,
  IngressVideoEncodingOptions,
);

function createBaseIngressInfo(): IngressInfo {
  return {
    $type: "livekit.IngressInfo",
    ingressId: "",
    name: "",
    streamKey: "",
    url: "",
    inputType: 0,
    bypassTranscoding: false,
    enableTranscoding: undefined,
    audio: undefined,
    video: undefined,
    roomName: "",
    participantIdentity: "",
    participantName: "",
    participantMetadata: "",
    reusable: false,
    state: undefined,
    enabled: undefined,
  };
}

export const IngressInfo: MessageFns<IngressInfo, "livekit.IngressInfo"> = {
  $type: "livekit.IngressInfo" as const,

  encode(
    message: IngressInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.ingressId !== "") {
      writer.uint32(10).string(message.ingressId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.streamKey !== "") {
      writer.uint32(26).string(message.streamKey);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    if (message.inputType !== 0) {
      writer.uint32(40).int32(message.inputType);
    }
    if (message.bypassTranscoding !== false) {
      writer.uint32(104).bool(message.bypassTranscoding);
    }
    if (message.enableTranscoding !== undefined) {
      writer.uint32(120).bool(message.enableTranscoding);
    }
    if (message.audio !== undefined) {
      IngressAudioOptions.encode(
        message.audio,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.video !== undefined) {
      IngressVideoOptions.encode(
        message.video,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.roomName !== "") {
      writer.uint32(66).string(message.roomName);
    }
    if (message.participantIdentity !== "") {
      writer.uint32(74).string(message.participantIdentity);
    }
    if (message.participantName !== "") {
      writer.uint32(82).string(message.participantName);
    }
    if (message.participantMetadata !== "") {
      writer.uint32(114).string(message.participantMetadata);
    }
    if (message.reusable !== false) {
      writer.uint32(88).bool(message.reusable);
    }
    if (message.state !== undefined) {
      IngressState.encode(message.state, writer.uint32(98).fork()).join();
    }
    if (message.enabled !== undefined) {
      writer.uint32(128).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngressInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngressInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ingressId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.streamKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.inputType = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.bypassTranscoding = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.enableTranscoding = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.audio = IngressAudioOptions.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.video = IngressVideoOptions.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.roomName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.participantIdentity = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.participantName = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.participantMetadata = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.reusable = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.state = IngressState.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngressInfo {
    return {
      $type: IngressInfo.$type,
      ingressId: isSet(object.ingressId)
        ? globalThis.String(object.ingressId)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      streamKey: isSet(object.streamKey)
        ? globalThis.String(object.streamKey)
        : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      inputType: isSet(object.inputType)
        ? ingressInputFromJSON(object.inputType)
        : 0,
      bypassTranscoding: isSet(object.bypassTranscoding)
        ? globalThis.Boolean(object.bypassTranscoding)
        : false,
      enableTranscoding: isSet(object.enableTranscoding)
        ? globalThis.Boolean(object.enableTranscoding)
        : undefined,
      audio: isSet(object.audio)
        ? IngressAudioOptions.fromJSON(object.audio)
        : undefined,
      video: isSet(object.video)
        ? IngressVideoOptions.fromJSON(object.video)
        : undefined,
      roomName: isSet(object.roomName)
        ? globalThis.String(object.roomName)
        : "",
      participantIdentity: isSet(object.participantIdentity)
        ? globalThis.String(object.participantIdentity)
        : "",
      participantName: isSet(object.participantName)
        ? globalThis.String(object.participantName)
        : "",
      participantMetadata: isSet(object.participantMetadata)
        ? globalThis.String(object.participantMetadata)
        : "",
      reusable: isSet(object.reusable)
        ? globalThis.Boolean(object.reusable)
        : false,
      state: isSet(object.state)
        ? IngressState.fromJSON(object.state)
        : undefined,
      enabled: isSet(object.enabled)
        ? globalThis.Boolean(object.enabled)
        : undefined,
    };
  },

  toJSON(message: IngressInfo): unknown {
    const obj: any = {};
    if (message.ingressId !== "") {
      obj.ingressId = message.ingressId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.streamKey !== "") {
      obj.streamKey = message.streamKey;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.inputType !== 0) {
      obj.inputType = ingressInputToJSON(message.inputType);
    }
    if (message.bypassTranscoding !== false) {
      obj.bypassTranscoding = message.bypassTranscoding;
    }
    if (message.enableTranscoding !== undefined) {
      obj.enableTranscoding = message.enableTranscoding;
    }
    if (message.audio !== undefined) {
      obj.audio = IngressAudioOptions.toJSON(message.audio);
    }
    if (message.video !== undefined) {
      obj.video = IngressVideoOptions.toJSON(message.video);
    }
    if (message.roomName !== "") {
      obj.roomName = message.roomName;
    }
    if (message.participantIdentity !== "") {
      obj.participantIdentity = message.participantIdentity;
    }
    if (message.participantName !== "") {
      obj.participantName = message.participantName;
    }
    if (message.participantMetadata !== "") {
      obj.participantMetadata = message.participantMetadata;
    }
    if (message.reusable !== false) {
      obj.reusable = message.reusable;
    }
    if (message.state !== undefined) {
      obj.state = IngressState.toJSON(message.state);
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IngressInfo>, I>>(base?: I): IngressInfo {
    return IngressInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IngressInfo>, I>>(
    object: I,
  ): IngressInfo {
    const message = createBaseIngressInfo();
    message.ingressId = object.ingressId ?? "";
    message.name = object.name ?? "";
    message.streamKey = object.streamKey ?? "";
    message.url = object.url ?? "";
    message.inputType = object.inputType ?? 0;
    message.bypassTranscoding = object.bypassTranscoding ?? false;
    message.enableTranscoding = object.enableTranscoding ?? undefined;
    message.audio =
      object.audio !== undefined && object.audio !== null
        ? IngressAudioOptions.fromPartial(object.audio)
        : undefined;
    message.video =
      object.video !== undefined && object.video !== null
        ? IngressVideoOptions.fromPartial(object.video)
        : undefined;
    message.roomName = object.roomName ?? "";
    message.participantIdentity = object.participantIdentity ?? "";
    message.participantName = object.participantName ?? "";
    message.participantMetadata = object.participantMetadata ?? "";
    message.reusable = object.reusable ?? false;
    message.state =
      object.state !== undefined && object.state !== null
        ? IngressState.fromPartial(object.state)
        : undefined;
    message.enabled = object.enabled ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(IngressInfo.$type, IngressInfo);

function createBaseIngressState(): IngressState {
  return {
    $type: "livekit.IngressState",
    status: 0,
    error: "",
    video: undefined,
    audio: undefined,
    roomId: "",
    startedAt: 0n,
    endedAt: 0n,
    updatedAt: 0n,
    resourceId: "",
    tracks: [],
  };
}

export const IngressState: MessageFns<IngressState, "livekit.IngressState"> = {
  $type: "livekit.IngressState" as const,

  encode(
    message: IngressState,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    if (message.video !== undefined) {
      InputVideoState.encode(message.video, writer.uint32(26).fork()).join();
    }
    if (message.audio !== undefined) {
      InputAudioState.encode(message.audio, writer.uint32(34).fork()).join();
    }
    if (message.roomId !== "") {
      writer.uint32(42).string(message.roomId);
    }
    if (message.startedAt !== 0n) {
      if (BigInt.asIntN(64, message.startedAt) !== message.startedAt) {
        throw new globalThis.Error(
          "value provided for field message.startedAt of type int64 too large",
        );
      }
      writer.uint32(56).int64(message.startedAt);
    }
    if (message.endedAt !== 0n) {
      if (BigInt.asIntN(64, message.endedAt) !== message.endedAt) {
        throw new globalThis.Error(
          "value provided for field message.endedAt of type int64 too large",
        );
      }
      writer.uint32(64).int64(message.endedAt);
    }
    if (message.updatedAt !== 0n) {
      if (BigInt.asIntN(64, message.updatedAt) !== message.updatedAt) {
        throw new globalThis.Error(
          "value provided for field message.updatedAt of type int64 too large",
        );
      }
      writer.uint32(80).int64(message.updatedAt);
    }
    if (message.resourceId !== "") {
      writer.uint32(74).string(message.resourceId);
    }
    for (const v of message.tracks) {
      TrackInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngressState {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngressState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.video = InputVideoState.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.audio = InputAudioState.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.startedAt = reader.int64() as bigint;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.endedAt = reader.int64() as bigint;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.updatedAt = reader.int64() as bigint;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tracks.push(TrackInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngressState {
    return {
      $type: IngressState.$type,
      status: isSet(object.status)
        ? ingressState_StatusFromJSON(object.status)
        : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      video: isSet(object.video)
        ? InputVideoState.fromJSON(object.video)
        : undefined,
      audio: isSet(object.audio)
        ? InputAudioState.fromJSON(object.audio)
        : undefined,
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      startedAt: isSet(object.startedAt) ? BigInt(object.startedAt) : 0n,
      endedAt: isSet(object.endedAt) ? BigInt(object.endedAt) : 0n,
      updatedAt: isSet(object.updatedAt) ? BigInt(object.updatedAt) : 0n,
      resourceId: isSet(object.resourceId)
        ? globalThis.String(object.resourceId)
        : "",
      tracks: globalThis.Array.isArray(object?.tracks)
        ? object.tracks.map((e: any) => TrackInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IngressState): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = ingressState_StatusToJSON(message.status);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.video !== undefined) {
      obj.video = InputVideoState.toJSON(message.video);
    }
    if (message.audio !== undefined) {
      obj.audio = InputAudioState.toJSON(message.audio);
    }
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.startedAt !== 0n) {
      obj.startedAt = message.startedAt.toString();
    }
    if (message.endedAt !== 0n) {
      obj.endedAt = message.endedAt.toString();
    }
    if (message.updatedAt !== 0n) {
      obj.updatedAt = message.updatedAt.toString();
    }
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.tracks?.length) {
      obj.tracks = message.tracks.map((e) => TrackInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IngressState>, I>>(
    base?: I,
  ): IngressState {
    return IngressState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IngressState>, I>>(
    object: I,
  ): IngressState {
    const message = createBaseIngressState();
    message.status = object.status ?? 0;
    message.error = object.error ?? "";
    message.video =
      object.video !== undefined && object.video !== null
        ? InputVideoState.fromPartial(object.video)
        : undefined;
    message.audio =
      object.audio !== undefined && object.audio !== null
        ? InputAudioState.fromPartial(object.audio)
        : undefined;
    message.roomId = object.roomId ?? "";
    message.startedAt = object.startedAt ?? 0n;
    message.endedAt = object.endedAt ?? 0n;
    message.updatedAt = object.updatedAt ?? 0n;
    message.resourceId = object.resourceId ?? "";
    message.tracks = object.tracks?.map((e) => TrackInfo.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(IngressState.$type, IngressState);

function createBaseInputVideoState(): InputVideoState {
  return {
    $type: "livekit.InputVideoState",
    mimeType: "",
    averageBitrate: 0,
    width: 0,
    height: 0,
    framerate: 0,
  };
}

export const InputVideoState: MessageFns<
  InputVideoState,
  "livekit.InputVideoState"
> = {
  $type: "livekit.InputVideoState" as const,

  encode(
    message: InputVideoState,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.mimeType !== "") {
      writer.uint32(10).string(message.mimeType);
    }
    if (message.averageBitrate !== 0) {
      writer.uint32(16).uint32(message.averageBitrate);
    }
    if (message.width !== 0) {
      writer.uint32(24).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(32).uint32(message.height);
    }
    if (message.framerate !== 0) {
      writer.uint32(41).double(message.framerate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputVideoState {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputVideoState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.averageBitrate = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.framerate = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputVideoState {
    return {
      $type: InputVideoState.$type,
      mimeType: isSet(object.mimeType)
        ? globalThis.String(object.mimeType)
        : "",
      averageBitrate: isSet(object.averageBitrate)
        ? globalThis.Number(object.averageBitrate)
        : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      framerate: isSet(object.framerate)
        ? globalThis.Number(object.framerate)
        : 0,
    };
  },

  toJSON(message: InputVideoState): unknown {
    const obj: any = {};
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.averageBitrate !== 0) {
      obj.averageBitrate = Math.round(message.averageBitrate);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.framerate !== 0) {
      obj.framerate = message.framerate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputVideoState>, I>>(
    base?: I,
  ): InputVideoState {
    return InputVideoState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputVideoState>, I>>(
    object: I,
  ): InputVideoState {
    const message = createBaseInputVideoState();
    message.mimeType = object.mimeType ?? "";
    message.averageBitrate = object.averageBitrate ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.framerate = object.framerate ?? 0;
    return message;
  },
};

messageTypeRegistry.set(InputVideoState.$type, InputVideoState);

function createBaseInputAudioState(): InputAudioState {
  return {
    $type: "livekit.InputAudioState",
    mimeType: "",
    averageBitrate: 0,
    channels: 0,
    sampleRate: 0,
  };
}

export const InputAudioState: MessageFns<
  InputAudioState,
  "livekit.InputAudioState"
> = {
  $type: "livekit.InputAudioState" as const,

  encode(
    message: InputAudioState,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.mimeType !== "") {
      writer.uint32(10).string(message.mimeType);
    }
    if (message.averageBitrate !== 0) {
      writer.uint32(16).uint32(message.averageBitrate);
    }
    if (message.channels !== 0) {
      writer.uint32(24).uint32(message.channels);
    }
    if (message.sampleRate !== 0) {
      writer.uint32(32).uint32(message.sampleRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputAudioState {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputAudioState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.averageBitrate = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channels = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sampleRate = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputAudioState {
    return {
      $type: InputAudioState.$type,
      mimeType: isSet(object.mimeType)
        ? globalThis.String(object.mimeType)
        : "",
      averageBitrate: isSet(object.averageBitrate)
        ? globalThis.Number(object.averageBitrate)
        : 0,
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
      sampleRate: isSet(object.sampleRate)
        ? globalThis.Number(object.sampleRate)
        : 0,
    };
  },

  toJSON(message: InputAudioState): unknown {
    const obj: any = {};
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.averageBitrate !== 0) {
      obj.averageBitrate = Math.round(message.averageBitrate);
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    if (message.sampleRate !== 0) {
      obj.sampleRate = Math.round(message.sampleRate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputAudioState>, I>>(
    base?: I,
  ): InputAudioState {
    return InputAudioState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputAudioState>, I>>(
    object: I,
  ): InputAudioState {
    const message = createBaseInputAudioState();
    message.mimeType = object.mimeType ?? "";
    message.averageBitrate = object.averageBitrate ?? 0;
    message.channels = object.channels ?? 0;
    message.sampleRate = object.sampleRate ?? 0;
    return message;
  },
};

messageTypeRegistry.set(InputAudioState.$type, InputAudioState);

function createBaseUpdateIngressRequest(): UpdateIngressRequest {
  return {
    $type: "livekit.UpdateIngressRequest",
    ingressId: "",
    name: "",
    roomName: "",
    participantIdentity: "",
    participantName: "",
    participantMetadata: "",
    bypassTranscoding: undefined,
    enableTranscoding: undefined,
    audio: undefined,
    video: undefined,
    enabled: undefined,
  };
}

export const UpdateIngressRequest: MessageFns<
  UpdateIngressRequest,
  "livekit.UpdateIngressRequest"
> = {
  $type: "livekit.UpdateIngressRequest" as const,

  encode(
    message: UpdateIngressRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.ingressId !== "") {
      writer.uint32(10).string(message.ingressId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.roomName !== "") {
      writer.uint32(26).string(message.roomName);
    }
    if (message.participantIdentity !== "") {
      writer.uint32(34).string(message.participantIdentity);
    }
    if (message.participantName !== "") {
      writer.uint32(42).string(message.participantName);
    }
    if (message.participantMetadata !== "") {
      writer.uint32(74).string(message.participantMetadata);
    }
    if (message.bypassTranscoding !== undefined) {
      writer.uint32(64).bool(message.bypassTranscoding);
    }
    if (message.enableTranscoding !== undefined) {
      writer.uint32(80).bool(message.enableTranscoding);
    }
    if (message.audio !== undefined) {
      IngressAudioOptions.encode(
        message.audio,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.video !== undefined) {
      IngressVideoOptions.encode(
        message.video,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.enabled !== undefined) {
      writer.uint32(88).bool(message.enabled);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UpdateIngressRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateIngressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ingressId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.roomName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.participantIdentity = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.participantName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.participantMetadata = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.bypassTranscoding = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.enableTranscoding = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.audio = IngressAudioOptions.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.video = IngressVideoOptions.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateIngressRequest {
    return {
      $type: UpdateIngressRequest.$type,
      ingressId: isSet(object.ingressId)
        ? globalThis.String(object.ingressId)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      roomName: isSet(object.roomName)
        ? globalThis.String(object.roomName)
        : "",
      participantIdentity: isSet(object.participantIdentity)
        ? globalThis.String(object.participantIdentity)
        : "",
      participantName: isSet(object.participantName)
        ? globalThis.String(object.participantName)
        : "",
      participantMetadata: isSet(object.participantMetadata)
        ? globalThis.String(object.participantMetadata)
        : "",
      bypassTranscoding: isSet(object.bypassTranscoding)
        ? globalThis.Boolean(object.bypassTranscoding)
        : undefined,
      enableTranscoding: isSet(object.enableTranscoding)
        ? globalThis.Boolean(object.enableTranscoding)
        : undefined,
      audio: isSet(object.audio)
        ? IngressAudioOptions.fromJSON(object.audio)
        : undefined,
      video: isSet(object.video)
        ? IngressVideoOptions.fromJSON(object.video)
        : undefined,
      enabled: isSet(object.enabled)
        ? globalThis.Boolean(object.enabled)
        : undefined,
    };
  },

  toJSON(message: UpdateIngressRequest): unknown {
    const obj: any = {};
    if (message.ingressId !== "") {
      obj.ingressId = message.ingressId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.roomName !== "") {
      obj.roomName = message.roomName;
    }
    if (message.participantIdentity !== "") {
      obj.participantIdentity = message.participantIdentity;
    }
    if (message.participantName !== "") {
      obj.participantName = message.participantName;
    }
    if (message.participantMetadata !== "") {
      obj.participantMetadata = message.participantMetadata;
    }
    if (message.bypassTranscoding !== undefined) {
      obj.bypassTranscoding = message.bypassTranscoding;
    }
    if (message.enableTranscoding !== undefined) {
      obj.enableTranscoding = message.enableTranscoding;
    }
    if (message.audio !== undefined) {
      obj.audio = IngressAudioOptions.toJSON(message.audio);
    }
    if (message.video !== undefined) {
      obj.video = IngressVideoOptions.toJSON(message.video);
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateIngressRequest>, I>>(
    base?: I,
  ): UpdateIngressRequest {
    return UpdateIngressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateIngressRequest>, I>>(
    object: I,
  ): UpdateIngressRequest {
    const message = createBaseUpdateIngressRequest();
    message.ingressId = object.ingressId ?? "";
    message.name = object.name ?? "";
    message.roomName = object.roomName ?? "";
    message.participantIdentity = object.participantIdentity ?? "";
    message.participantName = object.participantName ?? "";
    message.participantMetadata = object.participantMetadata ?? "";
    message.bypassTranscoding = object.bypassTranscoding ?? undefined;
    message.enableTranscoding = object.enableTranscoding ?? undefined;
    message.audio =
      object.audio !== undefined && object.audio !== null
        ? IngressAudioOptions.fromPartial(object.audio)
        : undefined;
    message.video =
      object.video !== undefined && object.video !== null
        ? IngressVideoOptions.fromPartial(object.video)
        : undefined;
    message.enabled = object.enabled ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(UpdateIngressRequest.$type, UpdateIngressRequest);

function createBaseListIngressRequest(): ListIngressRequest {
  return { $type: "livekit.ListIngressRequest", roomName: "", ingressId: "" };
}

export const ListIngressRequest: MessageFns<
  ListIngressRequest,
  "livekit.ListIngressRequest"
> = {
  $type: "livekit.ListIngressRequest" as const,

  encode(
    message: ListIngressRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.roomName !== "") {
      writer.uint32(10).string(message.roomName);
    }
    if (message.ingressId !== "") {
      writer.uint32(18).string(message.ingressId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ListIngressRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIngressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ingressId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIngressRequest {
    return {
      $type: ListIngressRequest.$type,
      roomName: isSet(object.roomName)
        ? globalThis.String(object.roomName)
        : "",
      ingressId: isSet(object.ingressId)
        ? globalThis.String(object.ingressId)
        : "",
    };
  },

  toJSON(message: ListIngressRequest): unknown {
    const obj: any = {};
    if (message.roomName !== "") {
      obj.roomName = message.roomName;
    }
    if (message.ingressId !== "") {
      obj.ingressId = message.ingressId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListIngressRequest>, I>>(
    base?: I,
  ): ListIngressRequest {
    return ListIngressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListIngressRequest>, I>>(
    object: I,
  ): ListIngressRequest {
    const message = createBaseListIngressRequest();
    message.roomName = object.roomName ?? "";
    message.ingressId = object.ingressId ?? "";
    return message;
  },
};

messageTypeRegistry.set(ListIngressRequest.$type, ListIngressRequest);

function createBaseListIngressResponse(): ListIngressResponse {
  return { $type: "livekit.ListIngressResponse", items: [] };
}

export const ListIngressResponse: MessageFns<
  ListIngressResponse,
  "livekit.ListIngressResponse"
> = {
  $type: "livekit.ListIngressResponse" as const,

  encode(
    message: ListIngressResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.items) {
      IngressInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ListIngressResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIngressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(IngressInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIngressResponse {
    return {
      $type: ListIngressResponse.$type,
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => IngressInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListIngressResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => IngressInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListIngressResponse>, I>>(
    base?: I,
  ): ListIngressResponse {
    return ListIngressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListIngressResponse>, I>>(
    object: I,
  ): ListIngressResponse {
    const message = createBaseListIngressResponse();
    message.items = object.items?.map((e) => IngressInfo.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(ListIngressResponse.$type, ListIngressResponse);

function createBaseDeleteIngressRequest(): DeleteIngressRequest {
  return { $type: "livekit.DeleteIngressRequest", ingressId: "" };
}

export const DeleteIngressRequest: MessageFns<
  DeleteIngressRequest,
  "livekit.DeleteIngressRequest"
> = {
  $type: "livekit.DeleteIngressRequest" as const,

  encode(
    message: DeleteIngressRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.ingressId !== "") {
      writer.uint32(10).string(message.ingressId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DeleteIngressRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIngressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ingressId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteIngressRequest {
    return {
      $type: DeleteIngressRequest.$type,
      ingressId: isSet(object.ingressId)
        ? globalThis.String(object.ingressId)
        : "",
    };
  },

  toJSON(message: DeleteIngressRequest): unknown {
    const obj: any = {};
    if (message.ingressId !== "") {
      obj.ingressId = message.ingressId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteIngressRequest>, I>>(
    base?: I,
  ): DeleteIngressRequest {
    return DeleteIngressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteIngressRequest>, I>>(
    object: I,
  ): DeleteIngressRequest {
    const message = createBaseDeleteIngressRequest();
    message.ingressId = object.ingressId ?? "";
    return message;
  },
};

messageTypeRegistry.set(DeleteIngressRequest.$type, DeleteIngressRequest);

type ProtoMetaMessageOptions = {
  options?: { [key: string]: any };
  fields?: { [key: string]: { [key: string]: any } };
  oneof?: { [key: string]: { [key: string]: any } };
  nested?: { [key: string]: ProtoMetaMessageOptions };
};

export interface ProtoMetadata {
  fileDescriptor: FileDescriptorProto1;
  references: { [key: string]: any };
  dependencies?: ProtoMetadata[];
  options?: {
    options?: { [key: string]: any };
    services?: {
      [key: string]: {
        options?: { [key: string]: any };
        methods?: { [key: string]: { [key: string]: any } };
      };
    };
    messages?: { [key: string]: ProtoMetaMessageOptions };
    enums?: {
      [key: string]: {
        options?: { [key: string]: any };
        values?: { [key: string]: { [key: string]: any } };
      };
    };
  };
}

export const protoMetadata = {
  fileDescriptor: {
    name: "livekit_ingress.proto",
    package: "livekit",
    dependency: ["livekit_models.proto"],
    publicDependency: [],
    weakDependency: [],
    messageType: [
      {
        name: "CreateIngressRequest",
        field: [
          {
            name: "input_type",
            number: 1,
            label: 1,
            type: 14,
            typeName: ".livekit.IngressInput",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "inputType",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "url",
            number: 9,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "url",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "name",
            number: 2,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "name",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "room_name",
            number: 3,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "roomName",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "participant_identity",
            number: 4,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "participantIdentity",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "participant_name",
            number: 5,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "participantName",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "participant_metadata",
            number: 10,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "participantMetadata",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "bypass_transcoding",
            number: 8,
            label: 1,
            type: 8,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "bypassTranscoding",
            options: {
              ctype: 0,
              packed: false,
              jstype: 0,
              lazy: false,
              deprecated: true,
              weak: false,
              uninterpretedOption: [],
            },
            proto3Optional: false,
          },
          {
            name: "enable_transcoding",
            number: 11,
            label: 1,
            type: 8,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "enableTranscoding",
            options: undefined,
            proto3Optional: true,
          },
          {
            name: "audio",
            number: 6,
            label: 1,
            type: 11,
            typeName: ".livekit.IngressAudioOptions",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "audio",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "video",
            number: 7,
            label: 1,
            type: 11,
            typeName: ".livekit.IngressVideoOptions",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "video",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "enabled",
            number: 12,
            label: 1,
            type: 8,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 1,
            jsonName: "enabled",
            options: undefined,
            proto3Optional: true,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [
          { name: "_enable_transcoding", options: undefined },
          {
            name: "_enabled",
            options: undefined,
          },
        ],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "IngressAudioOptions",
        field: [
          {
            name: "name",
            number: 1,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "name",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "source",
            number: 2,
            label: 1,
            type: 14,
            typeName: ".livekit.TrackSource",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "source",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "preset",
            number: 3,
            label: 1,
            type: 14,
            typeName: ".livekit.IngressAudioEncodingPreset",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "preset",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "options",
            number: 4,
            label: 1,
            type: 11,
            typeName: ".livekit.IngressAudioEncodingOptions",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "options",
            options: undefined,
            proto3Optional: false,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [{ name: "encoding_options", options: undefined }],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "IngressVideoOptions",
        field: [
          {
            name: "name",
            number: 1,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "name",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "source",
            number: 2,
            label: 1,
            type: 14,
            typeName: ".livekit.TrackSource",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "source",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "preset",
            number: 3,
            label: 1,
            type: 14,
            typeName: ".livekit.IngressVideoEncodingPreset",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "preset",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "options",
            number: 4,
            label: 1,
            type: 11,
            typeName: ".livekit.IngressVideoEncodingOptions",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "options",
            options: undefined,
            proto3Optional: false,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [{ name: "encoding_options", options: undefined }],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "IngressAudioEncodingOptions",
        field: [
          {
            name: "audio_codec",
            number: 1,
            label: 1,
            type: 14,
            typeName: ".livekit.AudioCodec",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "audioCodec",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "bitrate",
            number: 2,
            label: 1,
            type: 13,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "bitrate",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "disable_dtx",
            number: 3,
            label: 1,
            type: 8,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "disableDtx",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "channels",
            number: 4,
            label: 1,
            type: 13,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "channels",
            options: undefined,
            proto3Optional: false,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "IngressVideoEncodingOptions",
        field: [
          {
            name: "video_codec",
            number: 1,
            label: 1,
            type: 14,
            typeName: ".livekit.VideoCodec",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "videoCodec",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "frame_rate",
            number: 2,
            label: 1,
            type: 1,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "frameRate",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "layers",
            number: 3,
            label: 3,
            type: 11,
            typeName: ".livekit.VideoLayer",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "layers",
            options: undefined,
            proto3Optional: false,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "IngressInfo",
        field: [
          {
            name: "ingress_id",
            number: 1,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "ingressId",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "name",
            number: 2,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "name",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "stream_key",
            number: 3,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "streamKey",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "url",
            number: 4,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "url",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "input_type",
            number: 5,
            label: 1,
            type: 14,
            typeName: ".livekit.IngressInput",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "inputType",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "bypass_transcoding",
            number: 13,
            label: 1,
            type: 8,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "bypassTranscoding",
            options: {
              ctype: 0,
              packed: false,
              jstype: 0,
              lazy: false,
              deprecated: true,
              weak: false,
              uninterpretedOption: [],
            },
            proto3Optional: false,
          },
          {
            name: "enable_transcoding",
            number: 15,
            label: 1,
            type: 8,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "enableTranscoding",
            options: undefined,
            proto3Optional: true,
          },
          {
            name: "audio",
            number: 6,
            label: 1,
            type: 11,
            typeName: ".livekit.IngressAudioOptions",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "audio",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "video",
            number: 7,
            label: 1,
            type: 11,
            typeName: ".livekit.IngressVideoOptions",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "video",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "room_name",
            number: 8,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "roomName",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "participant_identity",
            number: 9,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "participantIdentity",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "participant_name",
            number: 10,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "participantName",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "participant_metadata",
            number: 14,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "participantMetadata",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "reusable",
            number: 11,
            label: 1,
            type: 8,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "reusable",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "state",
            number: 12,
            label: 1,
            type: 11,
            typeName: ".livekit.IngressState",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "state",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "enabled",
            number: 16,
            label: 1,
            type: 8,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 1,
            jsonName: "enabled",
            options: undefined,
            proto3Optional: true,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [
          { name: "_enable_transcoding", options: undefined },
          {
            name: "_enabled",
            options: undefined,
          },
        ],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "IngressState",
        field: [
          {
            name: "status",
            number: 1,
            label: 1,
            type: 14,
            typeName: ".livekit.IngressState.Status",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "status",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "error",
            number: 2,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "error",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "video",
            number: 3,
            label: 1,
            type: 11,
            typeName: ".livekit.InputVideoState",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "video",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "audio",
            number: 4,
            label: 1,
            type: 11,
            typeName: ".livekit.InputAudioState",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "audio",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "room_id",
            number: 5,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "roomId",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "started_at",
            number: 7,
            label: 1,
            type: 3,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "startedAt",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "ended_at",
            number: 8,
            label: 1,
            type: 3,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "endedAt",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "updated_at",
            number: 10,
            label: 1,
            type: 3,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "updatedAt",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "resource_id",
            number: 9,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "resourceId",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "tracks",
            number: 6,
            label: 3,
            type: 11,
            typeName: ".livekit.TrackInfo",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "tracks",
            options: undefined,
            proto3Optional: false,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [
          {
            name: "Status",
            value: [
              { name: "ENDPOINT_INACTIVE", number: 0, options: undefined },
              { name: "ENDPOINT_BUFFERING", number: 1, options: undefined },
              { name: "ENDPOINT_PUBLISHING", number: 2, options: undefined },
              { name: "ENDPOINT_ERROR", number: 3, options: undefined },
              { name: "ENDPOINT_COMPLETE", number: 4, options: undefined },
            ],
            options: undefined,
            reservedRange: [],
            reservedName: [],
          },
        ],
        extensionRange: [],
        oneofDecl: [],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "InputVideoState",
        field: [
          {
            name: "mime_type",
            number: 1,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "mimeType",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "average_bitrate",
            number: 2,
            label: 1,
            type: 13,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "averageBitrate",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "width",
            number: 3,
            label: 1,
            type: 13,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "width",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "height",
            number: 4,
            label: 1,
            type: 13,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "height",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "framerate",
            number: 5,
            label: 1,
            type: 1,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "framerate",
            options: undefined,
            proto3Optional: false,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "InputAudioState",
        field: [
          {
            name: "mime_type",
            number: 1,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "mimeType",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "average_bitrate",
            number: 2,
            label: 1,
            type: 13,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "averageBitrate",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "channels",
            number: 3,
            label: 1,
            type: 13,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "channels",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "sample_rate",
            number: 4,
            label: 1,
            type: 13,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "sampleRate",
            options: undefined,
            proto3Optional: false,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "UpdateIngressRequest",
        field: [
          {
            name: "ingress_id",
            number: 1,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "ingressId",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "name",
            number: 2,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "name",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "room_name",
            number: 3,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "roomName",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "participant_identity",
            number: 4,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "participantIdentity",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "participant_name",
            number: 5,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "participantName",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "participant_metadata",
            number: 9,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "participantMetadata",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "bypass_transcoding",
            number: 8,
            label: 1,
            type: 8,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "bypassTranscoding",
            options: {
              ctype: 0,
              packed: false,
              jstype: 0,
              lazy: false,
              deprecated: true,
              weak: false,
              uninterpretedOption: [],
            },
            proto3Optional: true,
          },
          {
            name: "enable_transcoding",
            number: 10,
            label: 1,
            type: 8,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 1,
            jsonName: "enableTranscoding",
            options: undefined,
            proto3Optional: true,
          },
          {
            name: "audio",
            number: 6,
            label: 1,
            type: 11,
            typeName: ".livekit.IngressAudioOptions",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "audio",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "video",
            number: 7,
            label: 1,
            type: 11,
            typeName: ".livekit.IngressVideoOptions",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "video",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "enabled",
            number: 11,
            label: 1,
            type: 8,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 2,
            jsonName: "enabled",
            options: undefined,
            proto3Optional: true,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [
          { name: "_bypass_transcoding", options: undefined },
          {
            name: "_enable_transcoding",
            options: undefined,
          },
          { name: "_enabled", options: undefined },
        ],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "ListIngressRequest",
        field: [
          {
            name: "room_name",
            number: 1,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "roomName",
            options: undefined,
            proto3Optional: false,
          },
          {
            name: "ingress_id",
            number: 2,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "ingressId",
            options: undefined,
            proto3Optional: false,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "ListIngressResponse",
        field: [
          {
            name: "items",
            number: 1,
            label: 3,
            type: 11,
            typeName: ".livekit.IngressInfo",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "items",
            options: undefined,
            proto3Optional: false,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "DeleteIngressRequest",
        field: [
          {
            name: "ingress_id",
            number: 1,
            label: 1,
            type: 9,
            typeName: "",
            extendee: "",
            defaultValue: "",
            oneofIndex: 0,
            jsonName: "ingressId",
            options: undefined,
            proto3Optional: false,
          },
        ],
        extension: [],
        nestedType: [],
        enumType: [],
        extensionRange: [],
        oneofDecl: [],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
    ],
    enumType: [
      {
        name: "IngressInput",
        value: [
          { name: "RTMP_INPUT", number: 0, options: undefined },
          {
            name: "WHIP_INPUT",
            number: 1,
            options: undefined,
          },
          { name: "URL_INPUT", number: 2, options: undefined },
        ],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "IngressAudioEncodingPreset",
        value: [
          { name: "OPUS_STEREO_96KBPS", number: 0, options: undefined },
          {
            name: "OPUS_MONO_64KBS",
            number: 1,
            options: undefined,
          },
        ],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
      {
        name: "IngressVideoEncodingPreset",
        value: [
          { name: "H264_720P_30FPS_3_LAYERS", number: 0, options: undefined },
          { name: "H264_1080P_30FPS_3_LAYERS", number: 1, options: undefined },
          { name: "H264_540P_25FPS_2_LAYERS", number: 2, options: undefined },
          { name: "H264_720P_30FPS_1_LAYER", number: 3, options: undefined },
          { name: "H264_1080P_30FPS_1_LAYER", number: 4, options: undefined },
          {
            name: "H264_720P_30FPS_3_LAYERS_HIGH_MOTION",
            number: 5,
            options: undefined,
          },
          {
            name: "H264_1080P_30FPS_3_LAYERS_HIGH_MOTION",
            number: 6,
            options: undefined,
          },
          {
            name: "H264_540P_25FPS_2_LAYERS_HIGH_MOTION",
            number: 7,
            options: undefined,
          },
          {
            name: "H264_720P_30FPS_1_LAYER_HIGH_MOTION",
            number: 8,
            options: undefined,
          },
          {
            name: "H264_1080P_30FPS_1_LAYER_HIGH_MOTION",
            number: 9,
            options: undefined,
          },
        ],
        options: undefined,
        reservedRange: [],
        reservedName: [],
      },
    ],
    service: [
      {
        name: "Ingress",
        method: [
          {
            name: "CreateIngress",
            inputType: ".livekit.CreateIngressRequest",
            outputType: ".livekit.IngressInfo",
            options: undefined,
            clientStreaming: false,
            serverStreaming: false,
          },
          {
            name: "UpdateIngress",
            inputType: ".livekit.UpdateIngressRequest",
            outputType: ".livekit.IngressInfo",
            options: undefined,
            clientStreaming: false,
            serverStreaming: false,
          },
          {
            name: "ListIngress",
            inputType: ".livekit.ListIngressRequest",
            outputType: ".livekit.ListIngressResponse",
            options: undefined,
            clientStreaming: false,
            serverStreaming: false,
          },
          {
            name: "DeleteIngress",
            inputType: ".livekit.DeleteIngressRequest",
            outputType: ".livekit.IngressInfo",
            options: undefined,
            clientStreaming: false,
            serverStreaming: false,
          },
        ],
        options: undefined,
      },
    ],
    extension: [],
    options: {
      javaPackage: "",
      javaOuterClassname: "",
      javaMultipleFiles: false,
      javaGenerateEqualsAndHash: false,
      javaStringCheckUtf8: false,
      optimizeFor: 1,
      goPackage: "github.com/livekit/protocol/livekit",
      ccGenericServices: false,
      javaGenericServices: false,
      pyGenericServices: false,
      phpGenericServices: false,
      deprecated: false,
      ccEnableArenas: true,
      objcClassPrefix: "",
      csharpNamespace: "LiveKit.Proto",
      swiftPrefix: "",
      phpClassPrefix: "",
      phpNamespace: "",
      phpMetadataNamespace: "",
      rubyPackage: "LiveKit::Proto",
      uninterpretedOption: [],
    },
    sourceCodeInfo: {
      location: [
        {
          path: [6, 0, 2, 0],
          span: [26, 2, 64],
          leadingComments: " Create a new Ingress\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [6, 0, 2, 1],
          span: [28, 2, 64],
          leadingComments:
            " Update an existing Ingress. Ingress can only be updated when it's in ENDPOINT_WAITING state.\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 0, 2, 1],
          span: [36, 2, 17],
          leadingComments:
            " Where to pull media from, only for URL input type\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 0, 2, 2],
          span: [38, 2, 18],
          leadingComments: " User provided identifier for the ingress\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 0, 2, 3],
          span: [40, 2, 23],
          leadingComments: " room to publish to\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 0, 2, 4],
          span: [42, 2, 34],
          leadingComments: " publish as participant\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 0, 2, 5],
          span: [44, 2, 30],
          leadingComments:
            " name of publishing participant (used for display only)\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 0, 2, 6],
          span: [46, 2, 35],
          leadingComments:
            " metadata associated with the publishing participant\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 0, 2, 7],
          span: [48, 2, 50],
          leadingComments:
            " [depreacted ] whether to pass through the incoming media without transcoding, only compatible with some input types. Use `enable_transcoding` instead.\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 0, 2, 8],
          span: [50, 2, 40],
          leadingComments:
            " Whether to transcode the ingested media. Only WHIP supports disabling transcoding currently. WHIP will default to transcoding disabled. Replaces `bypass_transcoding. \n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 0, 2, 11],
          span: [53, 2, 29],
          leadingComments: "",
          trailingComments:
            " The default value is true and when set to false, the new connection attempts will be rejected\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 0, 2, 2],
          span: [61, 2, 16],
          leadingComments: "",
          trailingComments:
            " Pull from the provided URL. Only HTTP url are supported, serving either a single media file or a HLS stream\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 1, 2, 0],
          span: [85, 2, 25],
          leadingComments: "",
          trailingComments: " OPUS, 2 channels, 96kbps\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 1, 2, 1],
          span: [86, 2, 22],
          leadingComments: "",
          trailingComments: " OPUS, 1 channel, 64kbps\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 2, 2, 0],
          span: [90, 2, 31],
          leadingComments: "",
          trailingComments:
            " 1280x720,  30fps, 1900kbps main layer, 3 layers total\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 2, 2, 1],
          span: [91, 2, 32],
          leadingComments: "",
          trailingComments:
            " 1980x1080, 30fps, 3500kbps main layer, 3 layers total\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 2, 2, 2],
          span: [92, 2, 31],
          leadingComments: "",
          trailingComments:
            "  960x540,  25fps, 1000kbps  main layer, 2 layers total\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 2, 2, 3],
          span: [93, 2, 30],
          leadingComments: "",
          trailingComments: " 1280x720,  30fps, 1900kbps, no simulcast\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 2, 2, 4],
          span: [94, 2, 31],
          leadingComments: "",
          trailingComments: " 1980x1080, 30fps, 3500kbps, no simulcast\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 2, 2, 5],
          span: [95, 2, 43],
          leadingComments: "",
          trailingComments:
            " 1280x720,  30fps, 2500kbps main layer, 3 layers total, higher bitrate for high motion, harder to encode content\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 2, 2, 6],
          span: [96, 2, 44],
          leadingComments: "",
          trailingComments:
            " 1980x1080, 30fps, 4500kbps main layer, 3 layers total, higher bitrate for high motion, harder to encode content\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 2, 2, 7],
          span: [97, 2, 43],
          leadingComments: "",
          trailingComments:
            "  960x540,  25fps, 1300kbps  main layer, 2 layers total, higher bitrate for high motion, harder to encode content\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 2, 2, 8],
          span: [98, 2, 42],
          leadingComments: "",
          trailingComments:
            " 1280x720,  30fps, 2500kbps, no simulcast, higher bitrate for high motion, harder to encode content\n",
          leadingDetachedComments: [],
        },
        {
          path: [5, 2, 2, 9],
          span: [99, 2, 43],
          leadingComments: "",
          trailingComments:
            " 1980x1080, 30fps, 4500kbps, no simulcast, higher bitrate for high motion, harder to encode content\n",
          leadingDetachedComments: [],
        },
        {
          path: [4, 3, 2, 0],
          span: [104, 2, 29],
          leadingComments: " desired audio codec to publish to room\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 4, 2, 0],
          span: [112, 2, 29],
          leadingComments: " desired codec to publish to room\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 4, 2, 2],
          span: [115, 2, 33],
          leadingComments:
            " simulcast layers to publish, when empty, should usually be set to layers at 1/2 and 1/4 of the dimensions\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 5, 2, 3],
          span: [122, 2, 17],
          leadingComments: "",
          trailingComments:
            " URL to point the encoder to for push (RTMP, WHIP), or location to pull media from for pull (URL)\n",
          leadingDetachedComments: [],
        },
        {
          path: [4, 5, 2, 4],
          span: [126, 2, 30],
          leadingComments:
            " for RTMP input, it'll be a rtmp:// URL\n for FILE input, it'll be a http:// URL\n for SRT input, it'll be a srt:// URL\n",
          trailingComments: "",
          leadingDetachedComments: [],
        },
        {
          path: [4, 5, 2, 14],
          span: [136, 2, 26],
          leadingComments: "",
          trailingComments:
            " Description of error/stream non compliance and debug info for publisher otherwise (received bitrate, resolution, bandwidth)\n",
          leadingDetachedComments: [],
        },
        {
          path: [4, 5, 2, 15],
          span: [137, 2, 29],
          leadingComments: "",
          trailingComments:
            " The default value is true and when set to false, the new connection attempts will be rejected\n",
          leadingDetachedComments: [],
        },
        {
          path: [4, 6, 2, 1],
          span: [152, 2, 19],
          leadingComments: "",
          trailingComments: " Error/non compliance description if any\n",
          leadingDetachedComments: [],
        },
        {
          path: [4, 6, 2, 4],
          span: [155, 2, 21],
          leadingComments: "",
          trailingComments: " ID of the current/previous room published to\n",
          leadingDetachedComments: [],
        },
        {
          path: [4, 9, 2, 10],
          span: [191, 2, 29],
          leadingComments: "",
          trailingComments:
            " The default value is true and when set to false, the new connection attempts will be rejected\n",
          leadingDetachedComments: [],
        },
        {
          path: [4, 10, 2, 0],
          span: [197, 2, 23],
          leadingComments: " when blank, lists all ingress endpoints\n",
          trailingComments: " (optional, filter by room name)\n",
          leadingDetachedComments: [],
        },
        {
          path: [4, 10, 2, 1],
          span: [198, 2, 24],
          leadingComments: "",
          trailingComments: " (optional, filter by ingress ID)\n",
          leadingDetachedComments: [],
        },
      ],
    },
    syntax: "proto3",
  },
  references: {
    ".livekit.IngressInput": IngressInput,
    ".livekit.IngressAudioEncodingPreset": IngressAudioEncodingPreset,
    ".livekit.IngressVideoEncodingPreset": IngressVideoEncodingPreset,
    ".livekit.CreateIngressRequest": CreateIngressRequest,
    ".livekit.IngressAudioOptions": IngressAudioOptions,
    ".livekit.IngressVideoOptions": IngressVideoOptions,
    ".livekit.IngressAudioEncodingOptions": IngressAudioEncodingOptions,
    ".livekit.IngressVideoEncodingOptions": IngressVideoEncodingOptions,
    ".livekit.IngressInfo": IngressInfo,
    ".livekit.IngressState": IngressState,
    ".livekit.IngressState.Status": IngressState_Status,
    ".livekit.InputVideoState": InputVideoState,
    ".livekit.InputAudioState": InputAudioState,
    ".livekit.UpdateIngressRequest": UpdateIngressRequest,
    ".livekit.ListIngressRequest": ListIngressRequest,
    ".livekit.ListIngressResponse": ListIngressResponse,
    ".livekit.DeleteIngressRequest": DeleteIngressRequest,
  },
  dependencies: [protoMetadata1],
} as const satisfies ProtoMetadata;

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | bigint
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
