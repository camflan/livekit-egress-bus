// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: livekit_room.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { FileDescriptorProto as FileDescriptorProto1 } from "ts-proto-descriptors";
import { protoMetadata as protoMetadata3, RoomAgentDispatch } from "./livekit_agent_dispatch";
import {
  AutoParticipantEgress,
  AutoTrackEgress,
  protoMetadata as protoMetadata2,
  RoomCompositeEgressRequest,
} from "./livekit_egress";
import {
  DataPacket_Kind,
  dataPacket_KindFromJSON,
  dataPacket_KindToJSON,
  ParticipantInfo,
  ParticipantPermission,
  ParticipantTracks,
  protoMetadata as protoMetadata1,
  Room,
  TrackInfo,
} from "./livekit_models";
import { messageTypeRegistry } from "./typeRegistry";

export const protobufPackage = "livekit";

export interface CreateRoomRequest {
  $type: "livekit.CreateRoomRequest";
  /** name of the room */
  name: string;
  /** configuration to use for this room parameters. Setting parameters below override the config defaults. */
  roomPreset: string;
  /** number of seconds to keep the room open if no one joins */
  emptyTimeout: number;
  /** number of seconds to keep the room open after everyone leaves */
  departureTimeout: number;
  /** limit number of participants that can be in a room */
  maxParticipants: number;
  /** override the node room is allocated to, for debugging */
  nodeId: string;
  /** metadata of room */
  metadata: string;
  /** auto-egress configurations */
  egress:
    | RoomEgress
    | undefined;
  /** playout delay of subscriber */
  minPlayoutDelay: number;
  maxPlayoutDelay: number;
  /**
   * improves A/V sync when playout_delay set to a value larger than 200ms. It will disables transceiver re-use
   * so not recommended for rooms with frequent subscription changes
   */
  syncStreams: boolean;
  /** replay */
  replayEnabled: boolean;
  /** Define agents that should be dispatched to this room */
  agents: RoomAgentDispatch[];
}

export interface RoomEgress {
  $type: "livekit.RoomEgress";
  room: RoomCompositeEgressRequest | undefined;
  participant: AutoParticipantEgress | undefined;
  tracks: AutoTrackEgress | undefined;
}

export interface RoomAgent {
  $type: "livekit.RoomAgent";
  dispatches: RoomAgentDispatch[];
}

export interface ListRoomsRequest {
  $type: "livekit.ListRoomsRequest";
  /** when set, will only return rooms with name match */
  names: string[];
}

export interface ListRoomsResponse {
  $type: "livekit.ListRoomsResponse";
  rooms: Room[];
}

export interface DeleteRoomRequest {
  $type: "livekit.DeleteRoomRequest";
  /** name of the room */
  room: string;
}

export interface DeleteRoomResponse {
  $type: "livekit.DeleteRoomResponse";
}

export interface ListParticipantsRequest {
  $type: "livekit.ListParticipantsRequest";
  /** name of the room */
  room: string;
}

export interface ListParticipantsResponse {
  $type: "livekit.ListParticipantsResponse";
  participants: ParticipantInfo[];
}

export interface RoomParticipantIdentity {
  $type: "livekit.RoomParticipantIdentity";
  /** name of the room */
  room: string;
  /** identity of the participant */
  identity: string;
}

export interface RemoveParticipantResponse {
  $type: "livekit.RemoveParticipantResponse";
}

export interface MuteRoomTrackRequest {
  $type: "livekit.MuteRoomTrackRequest";
  /** name of the room */
  room: string;
  identity: string;
  /** sid of the track to mute */
  trackSid: string;
  /** set to true to mute, false to unmute */
  muted: boolean;
}

export interface MuteRoomTrackResponse {
  $type: "livekit.MuteRoomTrackResponse";
  track: TrackInfo | undefined;
}

export interface UpdateParticipantRequest {
  $type: "livekit.UpdateParticipantRequest";
  room: string;
  identity: string;
  /** metadata to update. skipping updates if left empty */
  metadata: string;
  /** set to update the participant's permissions */
  permission:
    | ParticipantPermission
    | undefined;
  /** display name to update */
  name: string;
  /**
   * attributes to update. it only updates attributes that have been set
   * to delete attributes, set the value to an empty string
   */
  attributes: { [key: string]: string };
}

export interface UpdateParticipantRequest_AttributesEntry {
  $type: "livekit.UpdateParticipantRequest.AttributesEntry";
  key: string;
  value: string;
}

export interface UpdateSubscriptionsRequest {
  $type: "livekit.UpdateSubscriptionsRequest";
  room: string;
  identity: string;
  /** list of sids of tracks */
  trackSids: string[];
  /** set to true to subscribe, false to unsubscribe from tracks */
  subscribe: boolean;
  /** list of participants and their tracks */
  participantTracks: ParticipantTracks[];
}

/** empty for now */
export interface UpdateSubscriptionsResponse {
  $type: "livekit.UpdateSubscriptionsResponse";
}

export interface SendDataRequest {
  $type: "livekit.SendDataRequest";
  room: string;
  data: Buffer;
  kind: DataPacket_Kind;
  /**
   * mark deprecated
   *
   * @deprecated
   */
  destinationSids: string[];
  /** when set, only forward to these identities */
  destinationIdentities: string[];
  topic?:
    | string
    | undefined;
  /** added by SDK to enable de-duping of messages, for INTERNAL USE ONLY */
  nonce: Buffer;
}

/**  */
export interface SendDataResponse {
  $type: "livekit.SendDataResponse";
}

export interface UpdateRoomMetadataRequest {
  $type: "livekit.UpdateRoomMetadataRequest";
  room: string;
  /** metadata to update. skipping updates if left empty */
  metadata: string;
}

export interface RoomConfiguration {
  $type: "livekit.RoomConfiguration";
  /** Used as ID, must be unique */
  name: string;
  /** number of seconds to keep the room open if no one joins */
  emptyTimeout: number;
  /** number of seconds to keep the room open after everyone leaves */
  departureTimeout: number;
  /** limit number of participants that can be in a room, excluding Egress and Ingress participants */
  maxParticipants: number;
  /** egress */
  egress:
    | RoomEgress
    | undefined;
  /** playout delay of subscriber */
  minPlayoutDelay: number;
  maxPlayoutDelay: number;
  /**
   * improves A/V sync when playout_delay set to a value larger than 200ms. It will disables transceiver re-use
   * so not recommended for rooms with frequent subscription changes
   */
  syncStreams: boolean;
  /** Define agents that should be dispatched to this room */
  agents: RoomAgentDispatch[];
}

function createBaseCreateRoomRequest(): CreateRoomRequest {
  return {
    $type: "livekit.CreateRoomRequest",
    name: "",
    roomPreset: "",
    emptyTimeout: 0,
    departureTimeout: 0,
    maxParticipants: 0,
    nodeId: "",
    metadata: "",
    egress: undefined,
    minPlayoutDelay: 0,
    maxPlayoutDelay: 0,
    syncStreams: false,
    replayEnabled: false,
    agents: [],
  };
}

export const CreateRoomRequest: MessageFns<CreateRoomRequest, "livekit.CreateRoomRequest"> = {
  $type: "livekit.CreateRoomRequest" as const,

  encode(message: CreateRoomRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.roomPreset !== "") {
      writer.uint32(98).string(message.roomPreset);
    }
    if (message.emptyTimeout !== 0) {
      writer.uint32(16).uint32(message.emptyTimeout);
    }
    if (message.departureTimeout !== 0) {
      writer.uint32(80).uint32(message.departureTimeout);
    }
    if (message.maxParticipants !== 0) {
      writer.uint32(24).uint32(message.maxParticipants);
    }
    if (message.nodeId !== "") {
      writer.uint32(34).string(message.nodeId);
    }
    if (message.metadata !== "") {
      writer.uint32(42).string(message.metadata);
    }
    if (message.egress !== undefined) {
      RoomEgress.encode(message.egress, writer.uint32(50).fork()).join();
    }
    if (message.minPlayoutDelay !== 0) {
      writer.uint32(56).uint32(message.minPlayoutDelay);
    }
    if (message.maxPlayoutDelay !== 0) {
      writer.uint32(64).uint32(message.maxPlayoutDelay);
    }
    if (message.syncStreams !== false) {
      writer.uint32(72).bool(message.syncStreams);
    }
    if (message.replayEnabled !== false) {
      writer.uint32(104).bool(message.replayEnabled);
    }
    for (const v of message.agents) {
      RoomAgentDispatch.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRoomRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRoomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.roomPreset = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emptyTimeout = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.departureTimeout = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxParticipants = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.egress = RoomEgress.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.minPlayoutDelay = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxPlayoutDelay = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.syncStreams = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.replayEnabled = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.agents.push(RoomAgentDispatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRoomRequest {
    return {
      $type: CreateRoomRequest.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      roomPreset: isSet(object.roomPreset) ? globalThis.String(object.roomPreset) : "",
      emptyTimeout: isSet(object.emptyTimeout) ? globalThis.Number(object.emptyTimeout) : 0,
      departureTimeout: isSet(object.departureTimeout) ? globalThis.Number(object.departureTimeout) : 0,
      maxParticipants: isSet(object.maxParticipants) ? globalThis.Number(object.maxParticipants) : 0,
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      egress: isSet(object.egress) ? RoomEgress.fromJSON(object.egress) : undefined,
      minPlayoutDelay: isSet(object.minPlayoutDelay) ? globalThis.Number(object.minPlayoutDelay) : 0,
      maxPlayoutDelay: isSet(object.maxPlayoutDelay) ? globalThis.Number(object.maxPlayoutDelay) : 0,
      syncStreams: isSet(object.syncStreams) ? globalThis.Boolean(object.syncStreams) : false,
      replayEnabled: isSet(object.replayEnabled) ? globalThis.Boolean(object.replayEnabled) : false,
      agents: globalThis.Array.isArray(object?.agents)
        ? object.agents.map((e: any) => RoomAgentDispatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateRoomRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.roomPreset !== "") {
      obj.roomPreset = message.roomPreset;
    }
    if (message.emptyTimeout !== 0) {
      obj.emptyTimeout = Math.round(message.emptyTimeout);
    }
    if (message.departureTimeout !== 0) {
      obj.departureTimeout = Math.round(message.departureTimeout);
    }
    if (message.maxParticipants !== 0) {
      obj.maxParticipants = Math.round(message.maxParticipants);
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.egress !== undefined) {
      obj.egress = RoomEgress.toJSON(message.egress);
    }
    if (message.minPlayoutDelay !== 0) {
      obj.minPlayoutDelay = Math.round(message.minPlayoutDelay);
    }
    if (message.maxPlayoutDelay !== 0) {
      obj.maxPlayoutDelay = Math.round(message.maxPlayoutDelay);
    }
    if (message.syncStreams !== false) {
      obj.syncStreams = message.syncStreams;
    }
    if (message.replayEnabled !== false) {
      obj.replayEnabled = message.replayEnabled;
    }
    if (message.agents?.length) {
      obj.agents = message.agents.map((e) => RoomAgentDispatch.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateRoomRequest>, I>>(base?: I): CreateRoomRequest {
    return CreateRoomRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateRoomRequest>, I>>(object: I): CreateRoomRequest {
    const message = createBaseCreateRoomRequest();
    message.name = object.name ?? "";
    message.roomPreset = object.roomPreset ?? "";
    message.emptyTimeout = object.emptyTimeout ?? 0;
    message.departureTimeout = object.departureTimeout ?? 0;
    message.maxParticipants = object.maxParticipants ?? 0;
    message.nodeId = object.nodeId ?? "";
    message.metadata = object.metadata ?? "";
    message.egress = (object.egress !== undefined && object.egress !== null)
      ? RoomEgress.fromPartial(object.egress)
      : undefined;
    message.minPlayoutDelay = object.minPlayoutDelay ?? 0;
    message.maxPlayoutDelay = object.maxPlayoutDelay ?? 0;
    message.syncStreams = object.syncStreams ?? false;
    message.replayEnabled = object.replayEnabled ?? false;
    message.agents = object.agents?.map((e) => RoomAgentDispatch.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(CreateRoomRequest.$type, CreateRoomRequest);

function createBaseRoomEgress(): RoomEgress {
  return { $type: "livekit.RoomEgress", room: undefined, participant: undefined, tracks: undefined };
}

export const RoomEgress: MessageFns<RoomEgress, "livekit.RoomEgress"> = {
  $type: "livekit.RoomEgress" as const,

  encode(message: RoomEgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== undefined) {
      RoomCompositeEgressRequest.encode(message.room, writer.uint32(10).fork()).join();
    }
    if (message.participant !== undefined) {
      AutoParticipantEgress.encode(message.participant, writer.uint32(26).fork()).join();
    }
    if (message.tracks !== undefined) {
      AutoTrackEgress.encode(message.tracks, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomEgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomEgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = RoomCompositeEgressRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.participant = AutoParticipantEgress.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tracks = AutoTrackEgress.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomEgress {
    return {
      $type: RoomEgress.$type,
      room: isSet(object.room) ? RoomCompositeEgressRequest.fromJSON(object.room) : undefined,
      participant: isSet(object.participant) ? AutoParticipantEgress.fromJSON(object.participant) : undefined,
      tracks: isSet(object.tracks) ? AutoTrackEgress.fromJSON(object.tracks) : undefined,
    };
  },

  toJSON(message: RoomEgress): unknown {
    const obj: any = {};
    if (message.room !== undefined) {
      obj.room = RoomCompositeEgressRequest.toJSON(message.room);
    }
    if (message.participant !== undefined) {
      obj.participant = AutoParticipantEgress.toJSON(message.participant);
    }
    if (message.tracks !== undefined) {
      obj.tracks = AutoTrackEgress.toJSON(message.tracks);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoomEgress>, I>>(base?: I): RoomEgress {
    return RoomEgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoomEgress>, I>>(object: I): RoomEgress {
    const message = createBaseRoomEgress();
    message.room = (object.room !== undefined && object.room !== null)
      ? RoomCompositeEgressRequest.fromPartial(object.room)
      : undefined;
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? AutoParticipantEgress.fromPartial(object.participant)
      : undefined;
    message.tracks = (object.tracks !== undefined && object.tracks !== null)
      ? AutoTrackEgress.fromPartial(object.tracks)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RoomEgress.$type, RoomEgress);

function createBaseRoomAgent(): RoomAgent {
  return { $type: "livekit.RoomAgent", dispatches: [] };
}

export const RoomAgent: MessageFns<RoomAgent, "livekit.RoomAgent"> = {
  $type: "livekit.RoomAgent" as const,

  encode(message: RoomAgent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dispatches) {
      RoomAgentDispatch.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomAgent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomAgent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dispatches.push(RoomAgentDispatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomAgent {
    return {
      $type: RoomAgent.$type,
      dispatches: globalThis.Array.isArray(object?.dispatches)
        ? object.dispatches.map((e: any) => RoomAgentDispatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RoomAgent): unknown {
    const obj: any = {};
    if (message.dispatches?.length) {
      obj.dispatches = message.dispatches.map((e) => RoomAgentDispatch.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoomAgent>, I>>(base?: I): RoomAgent {
    return RoomAgent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoomAgent>, I>>(object: I): RoomAgent {
    const message = createBaseRoomAgent();
    message.dispatches = object.dispatches?.map((e) => RoomAgentDispatch.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(RoomAgent.$type, RoomAgent);

function createBaseListRoomsRequest(): ListRoomsRequest {
  return { $type: "livekit.ListRoomsRequest", names: [] };
}

export const ListRoomsRequest: MessageFns<ListRoomsRequest, "livekit.ListRoomsRequest"> = {
  $type: "livekit.ListRoomsRequest" as const,

  encode(message: ListRoomsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.names) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRoomsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRoomsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.names.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRoomsRequest {
    return {
      $type: ListRoomsRequest.$type,
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListRoomsRequest): unknown {
    const obj: any = {};
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRoomsRequest>, I>>(base?: I): ListRoomsRequest {
    return ListRoomsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRoomsRequest>, I>>(object: I): ListRoomsRequest {
    const message = createBaseListRoomsRequest();
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

messageTypeRegistry.set(ListRoomsRequest.$type, ListRoomsRequest);

function createBaseListRoomsResponse(): ListRoomsResponse {
  return { $type: "livekit.ListRoomsResponse", rooms: [] };
}

export const ListRoomsResponse: MessageFns<ListRoomsResponse, "livekit.ListRoomsResponse"> = {
  $type: "livekit.ListRoomsResponse" as const,

  encode(message: ListRoomsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rooms) {
      Room.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRoomsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRoomsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rooms.push(Room.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRoomsResponse {
    return {
      $type: ListRoomsResponse.$type,
      rooms: globalThis.Array.isArray(object?.rooms) ? object.rooms.map((e: any) => Room.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListRoomsResponse): unknown {
    const obj: any = {};
    if (message.rooms?.length) {
      obj.rooms = message.rooms.map((e) => Room.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRoomsResponse>, I>>(base?: I): ListRoomsResponse {
    return ListRoomsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRoomsResponse>, I>>(object: I): ListRoomsResponse {
    const message = createBaseListRoomsResponse();
    message.rooms = object.rooms?.map((e) => Room.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(ListRoomsResponse.$type, ListRoomsResponse);

function createBaseDeleteRoomRequest(): DeleteRoomRequest {
  return { $type: "livekit.DeleteRoomRequest", room: "" };
}

export const DeleteRoomRequest: MessageFns<DeleteRoomRequest, "livekit.DeleteRoomRequest"> = {
  $type: "livekit.DeleteRoomRequest" as const,

  encode(message: DeleteRoomRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRoomRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRoomRequest {
    return { $type: DeleteRoomRequest.$type, room: isSet(object.room) ? globalThis.String(object.room) : "" };
  },

  toJSON(message: DeleteRoomRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRoomRequest>, I>>(base?: I): DeleteRoomRequest {
    return DeleteRoomRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRoomRequest>, I>>(object: I): DeleteRoomRequest {
    const message = createBaseDeleteRoomRequest();
    message.room = object.room ?? "";
    return message;
  },
};

messageTypeRegistry.set(DeleteRoomRequest.$type, DeleteRoomRequest);

function createBaseDeleteRoomResponse(): DeleteRoomResponse {
  return { $type: "livekit.DeleteRoomResponse" };
}

export const DeleteRoomResponse: MessageFns<DeleteRoomResponse, "livekit.DeleteRoomResponse"> = {
  $type: "livekit.DeleteRoomResponse" as const,

  encode(_: DeleteRoomResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRoomResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteRoomResponse {
    return { $type: DeleteRoomResponse.$type };
  },

  toJSON(_: DeleteRoomResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRoomResponse>, I>>(base?: I): DeleteRoomResponse {
    return DeleteRoomResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRoomResponse>, I>>(_: I): DeleteRoomResponse {
    const message = createBaseDeleteRoomResponse();
    return message;
  },
};

messageTypeRegistry.set(DeleteRoomResponse.$type, DeleteRoomResponse);

function createBaseListParticipantsRequest(): ListParticipantsRequest {
  return { $type: "livekit.ListParticipantsRequest", room: "" };
}

export const ListParticipantsRequest: MessageFns<ListParticipantsRequest, "livekit.ListParticipantsRequest"> = {
  $type: "livekit.ListParticipantsRequest" as const,

  encode(message: ListParticipantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantsRequest {
    return { $type: ListParticipantsRequest.$type, room: isSet(object.room) ? globalThis.String(object.room) : "" };
  },

  toJSON(message: ListParticipantsRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListParticipantsRequest>, I>>(base?: I): ListParticipantsRequest {
    return ListParticipantsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListParticipantsRequest>, I>>(object: I): ListParticipantsRequest {
    const message = createBaseListParticipantsRequest();
    message.room = object.room ?? "";
    return message;
  },
};

messageTypeRegistry.set(ListParticipantsRequest.$type, ListParticipantsRequest);

function createBaseListParticipantsResponse(): ListParticipantsResponse {
  return { $type: "livekit.ListParticipantsResponse", participants: [] };
}

export const ListParticipantsResponse: MessageFns<ListParticipantsResponse, "livekit.ListParticipantsResponse"> = {
  $type: "livekit.ListParticipantsResponse" as const,

  encode(message: ListParticipantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.participants) {
      ParticipantInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participants.push(ParticipantInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantsResponse {
    return {
      $type: ListParticipantsResponse.$type,
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => ParticipantInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListParticipantsResponse): unknown {
    const obj: any = {};
    if (message.participants?.length) {
      obj.participants = message.participants.map((e) => ParticipantInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListParticipantsResponse>, I>>(base?: I): ListParticipantsResponse {
    return ListParticipantsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListParticipantsResponse>, I>>(object: I): ListParticipantsResponse {
    const message = createBaseListParticipantsResponse();
    message.participants = object.participants?.map((e) => ParticipantInfo.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(ListParticipantsResponse.$type, ListParticipantsResponse);

function createBaseRoomParticipantIdentity(): RoomParticipantIdentity {
  return { $type: "livekit.RoomParticipantIdentity", room: "", identity: "" };
}

export const RoomParticipantIdentity: MessageFns<RoomParticipantIdentity, "livekit.RoomParticipantIdentity"> = {
  $type: "livekit.RoomParticipantIdentity" as const,

  encode(message: RoomParticipantIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer.uint32(18).string(message.identity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomParticipantIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomParticipantIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomParticipantIdentity {
    return {
      $type: RoomParticipantIdentity.$type,
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
    };
  },

  toJSON(message: RoomParticipantIdentity): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoomParticipantIdentity>, I>>(base?: I): RoomParticipantIdentity {
    return RoomParticipantIdentity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoomParticipantIdentity>, I>>(object: I): RoomParticipantIdentity {
    const message = createBaseRoomParticipantIdentity();
    message.room = object.room ?? "";
    message.identity = object.identity ?? "";
    return message;
  },
};

messageTypeRegistry.set(RoomParticipantIdentity.$type, RoomParticipantIdentity);

function createBaseRemoveParticipantResponse(): RemoveParticipantResponse {
  return { $type: "livekit.RemoveParticipantResponse" };
}

export const RemoveParticipantResponse: MessageFns<RemoveParticipantResponse, "livekit.RemoveParticipantResponse"> = {
  $type: "livekit.RemoveParticipantResponse" as const,

  encode(_: RemoveParticipantResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveParticipantResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveParticipantResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveParticipantResponse {
    return { $type: RemoveParticipantResponse.$type };
  },

  toJSON(_: RemoveParticipantResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveParticipantResponse>, I>>(base?: I): RemoveParticipantResponse {
    return RemoveParticipantResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveParticipantResponse>, I>>(_: I): RemoveParticipantResponse {
    const message = createBaseRemoveParticipantResponse();
    return message;
  },
};

messageTypeRegistry.set(RemoveParticipantResponse.$type, RemoveParticipantResponse);

function createBaseMuteRoomTrackRequest(): MuteRoomTrackRequest {
  return { $type: "livekit.MuteRoomTrackRequest", room: "", identity: "", trackSid: "", muted: false };
}

export const MuteRoomTrackRequest: MessageFns<MuteRoomTrackRequest, "livekit.MuteRoomTrackRequest"> = {
  $type: "livekit.MuteRoomTrackRequest" as const,

  encode(message: MuteRoomTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer.uint32(18).string(message.identity);
    }
    if (message.trackSid !== "") {
      writer.uint32(26).string(message.trackSid);
    }
    if (message.muted !== false) {
      writer.uint32(32).bool(message.muted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuteRoomTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteRoomTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trackSid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.muted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteRoomTrackRequest {
    return {
      $type: MuteRoomTrackRequest.$type,
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
      trackSid: isSet(object.trackSid) ? globalThis.String(object.trackSid) : "",
      muted: isSet(object.muted) ? globalThis.Boolean(object.muted) : false,
    };
  },

  toJSON(message: MuteRoomTrackRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    if (message.trackSid !== "") {
      obj.trackSid = message.trackSid;
    }
    if (message.muted !== false) {
      obj.muted = message.muted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MuteRoomTrackRequest>, I>>(base?: I): MuteRoomTrackRequest {
    return MuteRoomTrackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MuteRoomTrackRequest>, I>>(object: I): MuteRoomTrackRequest {
    const message = createBaseMuteRoomTrackRequest();
    message.room = object.room ?? "";
    message.identity = object.identity ?? "";
    message.trackSid = object.trackSid ?? "";
    message.muted = object.muted ?? false;
    return message;
  },
};

messageTypeRegistry.set(MuteRoomTrackRequest.$type, MuteRoomTrackRequest);

function createBaseMuteRoomTrackResponse(): MuteRoomTrackResponse {
  return { $type: "livekit.MuteRoomTrackResponse", track: undefined };
}

export const MuteRoomTrackResponse: MessageFns<MuteRoomTrackResponse, "livekit.MuteRoomTrackResponse"> = {
  $type: "livekit.MuteRoomTrackResponse" as const,

  encode(message: MuteRoomTrackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackInfo.encode(message.track, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuteRoomTrackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteRoomTrackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteRoomTrackResponse {
    return {
      $type: MuteRoomTrackResponse.$type,
      track: isSet(object.track) ? TrackInfo.fromJSON(object.track) : undefined,
    };
  },

  toJSON(message: MuteRoomTrackResponse): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackInfo.toJSON(message.track);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MuteRoomTrackResponse>, I>>(base?: I): MuteRoomTrackResponse {
    return MuteRoomTrackResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MuteRoomTrackResponse>, I>>(object: I): MuteRoomTrackResponse {
    const message = createBaseMuteRoomTrackResponse();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackInfo.fromPartial(object.track)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(MuteRoomTrackResponse.$type, MuteRoomTrackResponse);

function createBaseUpdateParticipantRequest(): UpdateParticipantRequest {
  return {
    $type: "livekit.UpdateParticipantRequest",
    room: "",
    identity: "",
    metadata: "",
    permission: undefined,
    name: "",
    attributes: {},
  };
}

export const UpdateParticipantRequest: MessageFns<UpdateParticipantRequest, "livekit.UpdateParticipantRequest"> = {
  $type: "livekit.UpdateParticipantRequest" as const,

  encode(message: UpdateParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer.uint32(18).string(message.identity);
    }
    if (message.metadata !== "") {
      writer.uint32(26).string(message.metadata);
    }
    if (message.permission !== undefined) {
      ParticipantPermission.encode(message.permission, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      UpdateParticipantRequest_AttributesEntry.encode({
        $type: "livekit.UpdateParticipantRequest.AttributesEntry",
        key: key as any,
        value,
      }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.permission = ParticipantPermission.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = UpdateParticipantRequest_AttributesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.attributes[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateParticipantRequest {
    return {
      $type: UpdateParticipantRequest.$type,
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      permission: isSet(object.permission) ? ParticipantPermission.fromJSON(object.permission) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UpdateParticipantRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.permission !== undefined) {
      obj.permission = ParticipantPermission.toJSON(message.permission);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateParticipantRequest>, I>>(base?: I): UpdateParticipantRequest {
    return UpdateParticipantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateParticipantRequest>, I>>(object: I): UpdateParticipantRequest {
    const message = createBaseUpdateParticipantRequest();
    message.room = object.room ?? "";
    message.identity = object.identity ?? "";
    message.metadata = object.metadata ?? "";
    message.permission = (object.permission !== undefined && object.permission !== null)
      ? ParticipantPermission.fromPartial(object.permission)
      : undefined;
    message.name = object.name ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

messageTypeRegistry.set(UpdateParticipantRequest.$type, UpdateParticipantRequest);

function createBaseUpdateParticipantRequest_AttributesEntry(): UpdateParticipantRequest_AttributesEntry {
  return { $type: "livekit.UpdateParticipantRequest.AttributesEntry", key: "", value: "" };
}

export const UpdateParticipantRequest_AttributesEntry: MessageFns<
  UpdateParticipantRequest_AttributesEntry,
  "livekit.UpdateParticipantRequest.AttributesEntry"
> = {
  $type: "livekit.UpdateParticipantRequest.AttributesEntry" as const,

  encode(message: UpdateParticipantRequest_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateParticipantRequest_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParticipantRequest_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateParticipantRequest_AttributesEntry {
    return {
      $type: UpdateParticipantRequest_AttributesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UpdateParticipantRequest_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateParticipantRequest_AttributesEntry>, I>>(
    base?: I,
  ): UpdateParticipantRequest_AttributesEntry {
    return UpdateParticipantRequest_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateParticipantRequest_AttributesEntry>, I>>(
    object: I,
  ): UpdateParticipantRequest_AttributesEntry {
    const message = createBaseUpdateParticipantRequest_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(UpdateParticipantRequest_AttributesEntry.$type, UpdateParticipantRequest_AttributesEntry);

function createBaseUpdateSubscriptionsRequest(): UpdateSubscriptionsRequest {
  return {
    $type: "livekit.UpdateSubscriptionsRequest",
    room: "",
    identity: "",
    trackSids: [],
    subscribe: false,
    participantTracks: [],
  };
}

export const UpdateSubscriptionsRequest: MessageFns<UpdateSubscriptionsRequest, "livekit.UpdateSubscriptionsRequest"> =
  {
    $type: "livekit.UpdateSubscriptionsRequest" as const,

    encode(message: UpdateSubscriptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.room !== "") {
        writer.uint32(10).string(message.room);
      }
      if (message.identity !== "") {
        writer.uint32(18).string(message.identity);
      }
      for (const v of message.trackSids) {
        writer.uint32(26).string(v!);
      }
      if (message.subscribe !== false) {
        writer.uint32(32).bool(message.subscribe);
      }
      for (const v of message.participantTracks) {
        ParticipantTracks.encode(v!, writer.uint32(42).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubscriptionsRequest {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseUpdateSubscriptionsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.room = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.identity = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.trackSids.push(reader.string());
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.subscribe = reader.bool();
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.participantTracks.push(ParticipantTracks.decode(reader, reader.uint32()));
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): UpdateSubscriptionsRequest {
      return {
        $type: UpdateSubscriptionsRequest.$type,
        room: isSet(object.room) ? globalThis.String(object.room) : "",
        identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
        trackSids: globalThis.Array.isArray(object?.trackSids)
          ? object.trackSids.map((e: any) => globalThis.String(e))
          : [],
        subscribe: isSet(object.subscribe) ? globalThis.Boolean(object.subscribe) : false,
        participantTracks: globalThis.Array.isArray(object?.participantTracks)
          ? object.participantTracks.map((e: any) => ParticipantTracks.fromJSON(e))
          : [],
      };
    },

    toJSON(message: UpdateSubscriptionsRequest): unknown {
      const obj: any = {};
      if (message.room !== "") {
        obj.room = message.room;
      }
      if (message.identity !== "") {
        obj.identity = message.identity;
      }
      if (message.trackSids?.length) {
        obj.trackSids = message.trackSids;
      }
      if (message.subscribe !== false) {
        obj.subscribe = message.subscribe;
      }
      if (message.participantTracks?.length) {
        obj.participantTracks = message.participantTracks.map((e) => ParticipantTracks.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<UpdateSubscriptionsRequest>, I>>(base?: I): UpdateSubscriptionsRequest {
      return UpdateSubscriptionsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<UpdateSubscriptionsRequest>, I>>(object: I): UpdateSubscriptionsRequest {
      const message = createBaseUpdateSubscriptionsRequest();
      message.room = object.room ?? "";
      message.identity = object.identity ?? "";
      message.trackSids = object.trackSids?.map((e) => e) || [];
      message.subscribe = object.subscribe ?? false;
      message.participantTracks = object.participantTracks?.map((e) => ParticipantTracks.fromPartial(e)) || [];
      return message;
    },
  };

messageTypeRegistry.set(UpdateSubscriptionsRequest.$type, UpdateSubscriptionsRequest);

function createBaseUpdateSubscriptionsResponse(): UpdateSubscriptionsResponse {
  return { $type: "livekit.UpdateSubscriptionsResponse" };
}

export const UpdateSubscriptionsResponse: MessageFns<
  UpdateSubscriptionsResponse,
  "livekit.UpdateSubscriptionsResponse"
> = {
  $type: "livekit.UpdateSubscriptionsResponse" as const,

  encode(_: UpdateSubscriptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubscriptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateSubscriptionsResponse {
    return { $type: UpdateSubscriptionsResponse.$type };
  },

  toJSON(_: UpdateSubscriptionsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSubscriptionsResponse>, I>>(base?: I): UpdateSubscriptionsResponse {
    return UpdateSubscriptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSubscriptionsResponse>, I>>(_: I): UpdateSubscriptionsResponse {
    const message = createBaseUpdateSubscriptionsResponse();
    return message;
  },
};

messageTypeRegistry.set(UpdateSubscriptionsResponse.$type, UpdateSubscriptionsResponse);

function createBaseSendDataRequest(): SendDataRequest {
  return {
    $type: "livekit.SendDataRequest",
    room: "",
    data: Buffer.alloc(0),
    kind: 0,
    destinationSids: [],
    destinationIdentities: [],
    topic: undefined,
    nonce: Buffer.alloc(0),
  };
}

export const SendDataRequest: MessageFns<SendDataRequest, "livekit.SendDataRequest"> = {
  $type: "livekit.SendDataRequest" as const,

  encode(message: SendDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    for (const v of message.destinationSids) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.destinationIdentities) {
      writer.uint32(50).string(v!);
    }
    if (message.topic !== undefined) {
      writer.uint32(42).string(message.topic);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(58).bytes(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinationSids.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.destinationIdentities.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nonce = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendDataRequest {
    return {
      $type: SendDataRequest.$type,
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      kind: isSet(object.kind) ? dataPacket_KindFromJSON(object.kind) : 0,
      destinationSids: globalThis.Array.isArray(object?.destinationSids)
        ? object.destinationSids.map((e: any) => globalThis.String(e))
        : [],
      destinationIdentities: globalThis.Array.isArray(object?.destinationIdentities)
        ? object.destinationIdentities.map((e: any) => globalThis.String(e))
        : [],
      topic: isSet(object.topic) ? globalThis.String(object.topic) : undefined,
      nonce: isSet(object.nonce) ? Buffer.from(bytesFromBase64(object.nonce)) : Buffer.alloc(0),
    };
  },

  toJSON(message: SendDataRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.kind !== 0) {
      obj.kind = dataPacket_KindToJSON(message.kind);
    }
    if (message.destinationSids?.length) {
      obj.destinationSids = message.destinationSids;
    }
    if (message.destinationIdentities?.length) {
      obj.destinationIdentities = message.destinationIdentities;
    }
    if (message.topic !== undefined) {
      obj.topic = message.topic;
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendDataRequest>, I>>(base?: I): SendDataRequest {
    return SendDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendDataRequest>, I>>(object: I): SendDataRequest {
    const message = createBaseSendDataRequest();
    message.room = object.room ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    message.kind = object.kind ?? 0;
    message.destinationSids = object.destinationSids?.map((e) => e) || [];
    message.destinationIdentities = object.destinationIdentities?.map((e) => e) || [];
    message.topic = object.topic ?? undefined;
    message.nonce = object.nonce ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(SendDataRequest.$type, SendDataRequest);

function createBaseSendDataResponse(): SendDataResponse {
  return { $type: "livekit.SendDataResponse" };
}

export const SendDataResponse: MessageFns<SendDataResponse, "livekit.SendDataResponse"> = {
  $type: "livekit.SendDataResponse" as const,

  encode(_: SendDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SendDataResponse {
    return { $type: SendDataResponse.$type };
  },

  toJSON(_: SendDataResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SendDataResponse>, I>>(base?: I): SendDataResponse {
    return SendDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendDataResponse>, I>>(_: I): SendDataResponse {
    const message = createBaseSendDataResponse();
    return message;
  },
};

messageTypeRegistry.set(SendDataResponse.$type, SendDataResponse);

function createBaseUpdateRoomMetadataRequest(): UpdateRoomMetadataRequest {
  return { $type: "livekit.UpdateRoomMetadataRequest", room: "", metadata: "" };
}

export const UpdateRoomMetadataRequest: MessageFns<UpdateRoomMetadataRequest, "livekit.UpdateRoomMetadataRequest"> = {
  $type: "livekit.UpdateRoomMetadataRequest" as const,

  encode(message: UpdateRoomMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.metadata !== "") {
      writer.uint32(18).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRoomMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRoomMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRoomMetadataRequest {
    return {
      $type: UpdateRoomMetadataRequest.$type,
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
    };
  },

  toJSON(message: UpdateRoomMetadataRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRoomMetadataRequest>, I>>(base?: I): UpdateRoomMetadataRequest {
    return UpdateRoomMetadataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRoomMetadataRequest>, I>>(object: I): UpdateRoomMetadataRequest {
    const message = createBaseUpdateRoomMetadataRequest();
    message.room = object.room ?? "";
    message.metadata = object.metadata ?? "";
    return message;
  },
};

messageTypeRegistry.set(UpdateRoomMetadataRequest.$type, UpdateRoomMetadataRequest);

function createBaseRoomConfiguration(): RoomConfiguration {
  return {
    $type: "livekit.RoomConfiguration",
    name: "",
    emptyTimeout: 0,
    departureTimeout: 0,
    maxParticipants: 0,
    egress: undefined,
    minPlayoutDelay: 0,
    maxPlayoutDelay: 0,
    syncStreams: false,
    agents: [],
  };
}

export const RoomConfiguration: MessageFns<RoomConfiguration, "livekit.RoomConfiguration"> = {
  $type: "livekit.RoomConfiguration" as const,

  encode(message: RoomConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.emptyTimeout !== 0) {
      writer.uint32(16).uint32(message.emptyTimeout);
    }
    if (message.departureTimeout !== 0) {
      writer.uint32(24).uint32(message.departureTimeout);
    }
    if (message.maxParticipants !== 0) {
      writer.uint32(32).uint32(message.maxParticipants);
    }
    if (message.egress !== undefined) {
      RoomEgress.encode(message.egress, writer.uint32(42).fork()).join();
    }
    if (message.minPlayoutDelay !== 0) {
      writer.uint32(56).uint32(message.minPlayoutDelay);
    }
    if (message.maxPlayoutDelay !== 0) {
      writer.uint32(64).uint32(message.maxPlayoutDelay);
    }
    if (message.syncStreams !== false) {
      writer.uint32(72).bool(message.syncStreams);
    }
    for (const v of message.agents) {
      RoomAgentDispatch.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emptyTimeout = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.departureTimeout = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxParticipants = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.egress = RoomEgress.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.minPlayoutDelay = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxPlayoutDelay = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.syncStreams = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.agents.push(RoomAgentDispatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomConfiguration {
    return {
      $type: RoomConfiguration.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      emptyTimeout: isSet(object.emptyTimeout) ? globalThis.Number(object.emptyTimeout) : 0,
      departureTimeout: isSet(object.departureTimeout) ? globalThis.Number(object.departureTimeout) : 0,
      maxParticipants: isSet(object.maxParticipants) ? globalThis.Number(object.maxParticipants) : 0,
      egress: isSet(object.egress) ? RoomEgress.fromJSON(object.egress) : undefined,
      minPlayoutDelay: isSet(object.minPlayoutDelay) ? globalThis.Number(object.minPlayoutDelay) : 0,
      maxPlayoutDelay: isSet(object.maxPlayoutDelay) ? globalThis.Number(object.maxPlayoutDelay) : 0,
      syncStreams: isSet(object.syncStreams) ? globalThis.Boolean(object.syncStreams) : false,
      agents: globalThis.Array.isArray(object?.agents)
        ? object.agents.map((e: any) => RoomAgentDispatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RoomConfiguration): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.emptyTimeout !== 0) {
      obj.emptyTimeout = Math.round(message.emptyTimeout);
    }
    if (message.departureTimeout !== 0) {
      obj.departureTimeout = Math.round(message.departureTimeout);
    }
    if (message.maxParticipants !== 0) {
      obj.maxParticipants = Math.round(message.maxParticipants);
    }
    if (message.egress !== undefined) {
      obj.egress = RoomEgress.toJSON(message.egress);
    }
    if (message.minPlayoutDelay !== 0) {
      obj.minPlayoutDelay = Math.round(message.minPlayoutDelay);
    }
    if (message.maxPlayoutDelay !== 0) {
      obj.maxPlayoutDelay = Math.round(message.maxPlayoutDelay);
    }
    if (message.syncStreams !== false) {
      obj.syncStreams = message.syncStreams;
    }
    if (message.agents?.length) {
      obj.agents = message.agents.map((e) => RoomAgentDispatch.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoomConfiguration>, I>>(base?: I): RoomConfiguration {
    return RoomConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoomConfiguration>, I>>(object: I): RoomConfiguration {
    const message = createBaseRoomConfiguration();
    message.name = object.name ?? "";
    message.emptyTimeout = object.emptyTimeout ?? 0;
    message.departureTimeout = object.departureTimeout ?? 0;
    message.maxParticipants = object.maxParticipants ?? 0;
    message.egress = (object.egress !== undefined && object.egress !== null)
      ? RoomEgress.fromPartial(object.egress)
      : undefined;
    message.minPlayoutDelay = object.minPlayoutDelay ?? 0;
    message.maxPlayoutDelay = object.maxPlayoutDelay ?? 0;
    message.syncStreams = object.syncStreams ?? false;
    message.agents = object.agents?.map((e) => RoomAgentDispatch.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(RoomConfiguration.$type, RoomConfiguration);

type ProtoMetaMessageOptions = {
  options?: { [key: string]: any };
  fields?: { [key: string]: { [key: string]: any } };
  oneof?: { [key: string]: { [key: string]: any } };
  nested?: { [key: string]: ProtoMetaMessageOptions };
};

export interface ProtoMetadata {
  fileDescriptor: FileDescriptorProto1;
  references: { [key: string]: any };
  dependencies?: ProtoMetadata[];
  options?: {
    options?: { [key: string]: any };
    services?: {
      [key: string]: { options?: { [key: string]: any }; methods?: { [key: string]: { [key: string]: any } } };
    };
    messages?: { [key: string]: ProtoMetaMessageOptions };
    enums?: { [key: string]: { options?: { [key: string]: any }; values?: { [key: string]: { [key: string]: any } } } };
  };
}

export const protoMetadata = {
  fileDescriptor: {
    "name": "livekit_room.proto",
    "package": "livekit",
    "dependency": ["livekit_models.proto", "livekit_egress.proto", "livekit_agent_dispatch.proto"],
    "publicDependency": [],
    "weakDependency": [],
    "messageType": [{
      "name": "CreateRoomRequest",
      "field": [{
        "name": "name",
        "number": 1,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "name",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "room_preset",
        "number": 12,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "roomPreset",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "empty_timeout",
        "number": 2,
        "label": 1,
        "type": 13,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "emptyTimeout",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "departure_timeout",
        "number": 10,
        "label": 1,
        "type": 13,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "departureTimeout",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "max_participants",
        "number": 3,
        "label": 1,
        "type": 13,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "maxParticipants",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "node_id",
        "number": 4,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "nodeId",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "metadata",
        "number": 5,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "metadata",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "egress",
        "number": 6,
        "label": 1,
        "type": 11,
        "typeName": ".livekit.RoomEgress",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "egress",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "min_playout_delay",
        "number": 7,
        "label": 1,
        "type": 13,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "minPlayoutDelay",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "max_playout_delay",
        "number": 8,
        "label": 1,
        "type": 13,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "maxPlayoutDelay",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "sync_streams",
        "number": 9,
        "label": 1,
        "type": 8,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "syncStreams",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "replay_enabled",
        "number": 13,
        "label": 1,
        "type": 8,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "replayEnabled",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "agents",
        "number": 14,
        "label": 3,
        "type": 11,
        "typeName": ".livekit.RoomAgentDispatch",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "agents",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "RoomEgress",
      "field": [{
        "name": "room",
        "number": 1,
        "label": 1,
        "type": 11,
        "typeName": ".livekit.RoomCompositeEgressRequest",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "room",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "participant",
        "number": 3,
        "label": 1,
        "type": 11,
        "typeName": ".livekit.AutoParticipantEgress",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "participant",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "tracks",
        "number": 2,
        "label": 1,
        "type": 11,
        "typeName": ".livekit.AutoTrackEgress",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "tracks",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "RoomAgent",
      "field": [{
        "name": "dispatches",
        "number": 1,
        "label": 3,
        "type": 11,
        "typeName": ".livekit.RoomAgentDispatch",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "dispatches",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "ListRoomsRequest",
      "field": [{
        "name": "names",
        "number": 1,
        "label": 3,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "names",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "ListRoomsResponse",
      "field": [{
        "name": "rooms",
        "number": 1,
        "label": 3,
        "type": 11,
        "typeName": ".livekit.Room",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "rooms",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "DeleteRoomRequest",
      "field": [{
        "name": "room",
        "number": 1,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "room",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "DeleteRoomResponse",
      "field": [],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "ListParticipantsRequest",
      "field": [{
        "name": "room",
        "number": 1,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "room",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "ListParticipantsResponse",
      "field": [{
        "name": "participants",
        "number": 1,
        "label": 3,
        "type": 11,
        "typeName": ".livekit.ParticipantInfo",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "participants",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "RoomParticipantIdentity",
      "field": [{
        "name": "room",
        "number": 1,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "room",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "identity",
        "number": 2,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "identity",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "RemoveParticipantResponse",
      "field": [],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "MuteRoomTrackRequest",
      "field": [{
        "name": "room",
        "number": 1,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "room",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "identity",
        "number": 2,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "identity",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "track_sid",
        "number": 3,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "trackSid",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "muted",
        "number": 4,
        "label": 1,
        "type": 8,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "muted",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "MuteRoomTrackResponse",
      "field": [{
        "name": "track",
        "number": 1,
        "label": 1,
        "type": 11,
        "typeName": ".livekit.TrackInfo",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "track",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "UpdateParticipantRequest",
      "field": [{
        "name": "room",
        "number": 1,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "room",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "identity",
        "number": 2,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "identity",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "metadata",
        "number": 3,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "metadata",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "permission",
        "number": 4,
        "label": 1,
        "type": 11,
        "typeName": ".livekit.ParticipantPermission",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "permission",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "name",
        "number": 5,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "name",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "attributes",
        "number": 6,
        "label": 3,
        "type": 11,
        "typeName": ".livekit.UpdateParticipantRequest.AttributesEntry",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "attributes",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [{
        "name": "AttributesEntry",
        "field": [{
          "name": "key",
          "number": 1,
          "label": 1,
          "type": 9,
          "typeName": "",
          "extendee": "",
          "defaultValue": "",
          "oneofIndex": 0,
          "jsonName": "key",
          "options": undefined,
          "proto3Optional": false,
        }, {
          "name": "value",
          "number": 2,
          "label": 1,
          "type": 9,
          "typeName": "",
          "extendee": "",
          "defaultValue": "",
          "oneofIndex": 0,
          "jsonName": "value",
          "options": undefined,
          "proto3Optional": false,
        }],
        "extension": [],
        "nestedType": [],
        "enumType": [],
        "extensionRange": [],
        "oneofDecl": [],
        "options": {
          "messageSetWireFormat": false,
          "noStandardDescriptorAccessor": false,
          "deprecated": false,
          "mapEntry": true,
          "uninterpretedOption": [],
        },
        "reservedRange": [],
        "reservedName": [],
      }],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "UpdateSubscriptionsRequest",
      "field": [{
        "name": "room",
        "number": 1,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "room",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "identity",
        "number": 2,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "identity",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "track_sids",
        "number": 3,
        "label": 3,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "trackSids",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "subscribe",
        "number": 4,
        "label": 1,
        "type": 8,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "subscribe",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "participant_tracks",
        "number": 5,
        "label": 3,
        "type": 11,
        "typeName": ".livekit.ParticipantTracks",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "participantTracks",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "UpdateSubscriptionsResponse",
      "field": [],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "SendDataRequest",
      "field": [{
        "name": "room",
        "number": 1,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "room",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "data",
        "number": 2,
        "label": 1,
        "type": 12,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "data",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "kind",
        "number": 3,
        "label": 1,
        "type": 14,
        "typeName": ".livekit.DataPacket.Kind",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "kind",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "destination_sids",
        "number": 4,
        "label": 3,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "destinationSids",
        "options": {
          "ctype": 0,
          "packed": false,
          "jstype": 0,
          "lazy": false,
          "deprecated": true,
          "weak": false,
          "uninterpretedOption": [],
        },
        "proto3Optional": false,
      }, {
        "name": "destination_identities",
        "number": 6,
        "label": 3,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "destinationIdentities",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "topic",
        "number": 5,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "topic",
        "options": undefined,
        "proto3Optional": true,
      }, {
        "name": "nonce",
        "number": 7,
        "label": 1,
        "type": 12,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "nonce",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [{ "name": "_topic", "options": undefined }],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "SendDataResponse",
      "field": [],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "UpdateRoomMetadataRequest",
      "field": [{
        "name": "room",
        "number": 1,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "room",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "metadata",
        "number": 2,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "metadata",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }, {
      "name": "RoomConfiguration",
      "field": [{
        "name": "name",
        "number": 1,
        "label": 1,
        "type": 9,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "name",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "empty_timeout",
        "number": 2,
        "label": 1,
        "type": 13,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "emptyTimeout",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "departure_timeout",
        "number": 3,
        "label": 1,
        "type": 13,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "departureTimeout",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "max_participants",
        "number": 4,
        "label": 1,
        "type": 13,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "maxParticipants",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "egress",
        "number": 5,
        "label": 1,
        "type": 11,
        "typeName": ".livekit.RoomEgress",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "egress",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "min_playout_delay",
        "number": 7,
        "label": 1,
        "type": 13,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "minPlayoutDelay",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "max_playout_delay",
        "number": 8,
        "label": 1,
        "type": 13,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "maxPlayoutDelay",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "sync_streams",
        "number": 9,
        "label": 1,
        "type": 8,
        "typeName": "",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "syncStreams",
        "options": undefined,
        "proto3Optional": false,
      }, {
        "name": "agents",
        "number": 10,
        "label": 3,
        "type": 11,
        "typeName": ".livekit.RoomAgentDispatch",
        "extendee": "",
        "defaultValue": "",
        "oneofIndex": 0,
        "jsonName": "agents",
        "options": undefined,
        "proto3Optional": false,
      }],
      "extension": [],
      "nestedType": [],
      "enumType": [],
      "extensionRange": [],
      "oneofDecl": [],
      "options": undefined,
      "reservedRange": [],
      "reservedName": [],
    }],
    "enumType": [],
    "service": [{
      "name": "RoomService",
      "method": [{
        "name": "CreateRoom",
        "inputType": ".livekit.CreateRoomRequest",
        "outputType": ".livekit.Room",
        "options": undefined,
        "clientStreaming": false,
        "serverStreaming": false,
      }, {
        "name": "ListRooms",
        "inputType": ".livekit.ListRoomsRequest",
        "outputType": ".livekit.ListRoomsResponse",
        "options": undefined,
        "clientStreaming": false,
        "serverStreaming": false,
      }, {
        "name": "DeleteRoom",
        "inputType": ".livekit.DeleteRoomRequest",
        "outputType": ".livekit.DeleteRoomResponse",
        "options": undefined,
        "clientStreaming": false,
        "serverStreaming": false,
      }, {
        "name": "ListParticipants",
        "inputType": ".livekit.ListParticipantsRequest",
        "outputType": ".livekit.ListParticipantsResponse",
        "options": undefined,
        "clientStreaming": false,
        "serverStreaming": false,
      }, {
        "name": "GetParticipant",
        "inputType": ".livekit.RoomParticipantIdentity",
        "outputType": ".livekit.ParticipantInfo",
        "options": undefined,
        "clientStreaming": false,
        "serverStreaming": false,
      }, {
        "name": "RemoveParticipant",
        "inputType": ".livekit.RoomParticipantIdentity",
        "outputType": ".livekit.RemoveParticipantResponse",
        "options": undefined,
        "clientStreaming": false,
        "serverStreaming": false,
      }, {
        "name": "MutePublishedTrack",
        "inputType": ".livekit.MuteRoomTrackRequest",
        "outputType": ".livekit.MuteRoomTrackResponse",
        "options": undefined,
        "clientStreaming": false,
        "serverStreaming": false,
      }, {
        "name": "UpdateParticipant",
        "inputType": ".livekit.UpdateParticipantRequest",
        "outputType": ".livekit.ParticipantInfo",
        "options": undefined,
        "clientStreaming": false,
        "serverStreaming": false,
      }, {
        "name": "UpdateSubscriptions",
        "inputType": ".livekit.UpdateSubscriptionsRequest",
        "outputType": ".livekit.UpdateSubscriptionsResponse",
        "options": undefined,
        "clientStreaming": false,
        "serverStreaming": false,
      }, {
        "name": "SendData",
        "inputType": ".livekit.SendDataRequest",
        "outputType": ".livekit.SendDataResponse",
        "options": undefined,
        "clientStreaming": false,
        "serverStreaming": false,
      }, {
        "name": "UpdateRoomMetadata",
        "inputType": ".livekit.UpdateRoomMetadataRequest",
        "outputType": ".livekit.Room",
        "options": undefined,
        "clientStreaming": false,
        "serverStreaming": false,
      }],
      "options": undefined,
    }],
    "extension": [],
    "options": {
      "javaPackage": "",
      "javaOuterClassname": "",
      "javaMultipleFiles": false,
      "javaGenerateEqualsAndHash": false,
      "javaStringCheckUtf8": false,
      "optimizeFor": 1,
      "goPackage": "github.com/livekit/protocol/livekit",
      "ccGenericServices": false,
      "javaGenericServices": false,
      "pyGenericServices": false,
      "phpGenericServices": false,
      "deprecated": false,
      "ccEnableArenas": true,
      "objcClassPrefix": "",
      "csharpNamespace": "LiveKit.Proto",
      "swiftPrefix": "",
      "phpClassPrefix": "",
      "phpNamespace": "",
      "phpMetadataNamespace": "",
      "rubyPackage": "LiveKit::Proto",
      "uninterpretedOption": [],
    },
    "sourceCodeInfo": {
      "location": [{
        "path": [6, 0],
        "span": [27, 0, 62, 1],
        "leadingComments":
          " Room service that can be performed on any node\n they are Twirp-based HTTP req/responses\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [6, 0, 2, 0],
        "span": [30, 2, 51],
        "leadingComments":
          " Creates a room with settings. Requires `roomCreate` permission.\n This method is optional; rooms are automatically created when clients connect to them for the first time.\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [6, 0, 2, 1],
        "span": [33, 2, 62],
        "leadingComments": " List rooms that are active on the server. Requires `roomList` permission.\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [6, 0, 2, 2],
        "span": [37, 2, 65],
        "leadingComments":
          " Deletes an existing room by name or id. Requires `roomCreate` permission.\n DeleteRoom will disconnect all participants that are currently in the room.\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [6, 0, 2, 3],
        "span": [40, 2, 83],
        "leadingComments": " Lists participants in a room, Requires `roomAdmin`\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [6, 0, 2, 4],
        "span": [43, 2, 72],
        "leadingComments": " Get information on a specific participant, Requires `roomAdmin`\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [6, 0, 2, 5],
        "span": [46, 2, 85],
        "leadingComments": " Removes a participant from room. Requires `roomAdmin`\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [6, 0, 2, 6],
        "span": [49, 2, 79],
        "leadingComments": " Mute/unmute a participant's track, Requires `roomAdmin`\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [6, 0, 2, 7],
        "span": [52, 2, 76],
        "leadingComments":
          " Update participant metadata, will cause updates to be broadcasted to everyone in the room. Requires `roomAdmin`\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [6, 0, 2, 8],
        "span": [55, 2, 92],
        "leadingComments": " Subscribes or unsubscribe a participant from tracks. Requires `roomAdmin`\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [6, 0, 2, 9],
        "span": [58, 2, 59],
        "leadingComments": " Send data over data channel to participants in a room, Requires `roomAdmin`\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [6, 0, 2, 10],
        "span": [61, 2, 68],
        "leadingComments":
          " Update room metadata, will cause updates to be broadcasted to everyone in the room, Requires `roomAdmin`\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 0],
        "span": [66, 2, 18],
        "leadingComments": " name of the room\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 1],
        "span": [68, 2, 26],
        "leadingComments":
          " configuration to use for this room parameters. Setting parameters below override the config defaults.\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 2],
        "span": [70, 2, 27],
        "leadingComments": " number of seconds to keep the room open if no one joins\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 3],
        "span": [72, 2, 32],
        "leadingComments": " number of seconds to keep the room open after everyone leaves\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 4],
        "span": [74, 2, 30],
        "leadingComments": " limit number of participants that can be in a room\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 5],
        "span": [76, 2, 21],
        "leadingComments": " override the node room is allocated to, for debugging\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 6],
        "span": [78, 2, 22],
        "leadingComments": " metadata of room\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 7],
        "span": [80, 2, 24],
        "leadingComments": " auto-egress configurations\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 8],
        "span": [82, 2, 31],
        "leadingComments": " playout delay of subscriber\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 10],
        "span": [86, 2, 24],
        "leadingComments":
          " improves A/V sync when playout_delay set to a value larger than 200ms. It will disables transceiver re-use\n so not recommended for rooms with frequent subscription changes\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 11],
        "span": [88, 2, 27],
        "leadingComments": " replay\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 0, 2, 12],
        "span": [91, 2, 41],
        "leadingComments": " Define agents that should be dispatched to this room\n",
        "trailingComments": " NEXT-ID: 15\n",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 3, 2, 0],
        "span": [108, 2, 28],
        "leadingComments": " when set, will only return rooms with name match\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 5, 2, 0],
        "span": [117, 2, 18],
        "leadingComments": " name of the room\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 7, 2, 0],
        "span": [125, 2, 18],
        "leadingComments": " name of the room\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 9, 2, 0],
        "span": [134, 2, 18],
        "leadingComments": " name of the room\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 9, 2, 1],
        "span": [136, 2, 22],
        "leadingComments": " identity of the participant\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 11, 2, 0],
        "span": [144, 2, 18],
        "leadingComments": " name of the room\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 11, 2, 2],
        "span": [147, 2, 23],
        "leadingComments": " sid of the track to mute\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 11, 2, 3],
        "span": [149, 2, 17],
        "leadingComments": " set to true to mute, false to unmute\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 13, 2, 2],
        "span": [160, 2, 22],
        "leadingComments": " metadata to update. skipping updates if left empty\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 13, 2, 3],
        "span": [162, 2, 39],
        "leadingComments": " set to update the participant's permissions\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 13, 2, 4],
        "span": [164, 2, 18],
        "leadingComments": " display name to update\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 13, 2, 5],
        "span": [167, 2, 37],
        "leadingComments":
          " attributes to update. it only updates attributes that have been set\n to delete attributes, set the value to an empty string\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 14, 2, 2],
        "span": [174, 2, 33],
        "leadingComments": " list of sids of tracks\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 14, 2, 3],
        "span": [176, 2, 21],
        "leadingComments": " set to true to subscribe, false to unsubscribe from tracks\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 14, 2, 4],
        "span": [178, 2, 52],
        "leadingComments": " list of participants and their tracks\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 15],
        "span": [181, 0, 183, 1],
        "leadingComments": "",
        "trailingComments": " empty for now\n",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 16, 2, 3],
        "span": [190, 2, 57],
        "leadingComments": " mark deprecated\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 16, 2, 4],
        "span": [192, 2, 45],
        "leadingComments": " when set, only forward to these identities\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 16, 2, 6],
        "span": [195, 2, 18],
        "leadingComments": " added by SDK to enable de-duping of messages, for INTERNAL USE ONLY\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 17],
        "span": [200, 0, 202, 1],
        "leadingComments": "",
        "trailingComments": "\n",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 18, 2, 1],
        "span": [207, 2, 22],
        "leadingComments": " metadata to update. skipping updates if left empty\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 19, 2, 0],
        "span": [211, 2, 18],
        "leadingComments": "",
        "trailingComments": " Used as ID, must be unique\n",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 19, 2, 1],
        "span": [213, 2, 27],
        "leadingComments": " number of seconds to keep the room open if no one joins\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 19, 2, 2],
        "span": [215, 2, 31],
        "leadingComments": " number of seconds to keep the room open after everyone leaves\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 19, 2, 3],
        "span": [217, 2, 30],
        "leadingComments":
          " limit number of participants that can be in a room, excluding Egress and Ingress participants\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 19, 2, 4],
        "span": [219, 2, 24],
        "leadingComments": " egress\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 19, 2, 5],
        "span": [221, 2, 31],
        "leadingComments": " playout delay of subscriber\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 19, 2, 7],
        "span": [225, 2, 24],
        "leadingComments":
          " improves A/V sync when playout_delay set to a value larger than 200ms. It will disables transceiver re-use\n so not recommended for rooms with frequent subscription changes\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }, {
        "path": [4, 19, 2, 8],
        "span": [228, 2, 41],
        "leadingComments": " Define agents that should be dispatched to this room\n",
        "trailingComments": "",
        "leadingDetachedComments": [],
      }],
    },
    "syntax": "proto3",
  },
  references: {
    ".livekit.CreateRoomRequest": CreateRoomRequest,
    ".livekit.RoomEgress": RoomEgress,
    ".livekit.RoomAgent": RoomAgent,
    ".livekit.ListRoomsRequest": ListRoomsRequest,
    ".livekit.ListRoomsResponse": ListRoomsResponse,
    ".livekit.DeleteRoomRequest": DeleteRoomRequest,
    ".livekit.DeleteRoomResponse": DeleteRoomResponse,
    ".livekit.ListParticipantsRequest": ListParticipantsRequest,
    ".livekit.ListParticipantsResponse": ListParticipantsResponse,
    ".livekit.RoomParticipantIdentity": RoomParticipantIdentity,
    ".livekit.RemoveParticipantResponse": RemoveParticipantResponse,
    ".livekit.MuteRoomTrackRequest": MuteRoomTrackRequest,
    ".livekit.MuteRoomTrackResponse": MuteRoomTrackResponse,
    ".livekit.UpdateParticipantRequest": UpdateParticipantRequest,
    ".livekit.UpdateParticipantRequest.AttributesEntry": UpdateParticipantRequest_AttributesEntry,
    ".livekit.UpdateSubscriptionsRequest": UpdateSubscriptionsRequest,
    ".livekit.UpdateSubscriptionsResponse": UpdateSubscriptionsResponse,
    ".livekit.SendDataRequest": SendDataRequest,
    ".livekit.SendDataResponse": SendDataResponse,
    ".livekit.UpdateRoomMetadataRequest": UpdateRoomMetadataRequest,
    ".livekit.RoomConfiguration": RoomConfiguration,
  },
  dependencies: [protoMetadata1, protoMetadata2, protoMetadata3],
} as const satisfies ProtoMetadata;

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
