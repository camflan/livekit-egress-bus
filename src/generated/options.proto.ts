// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v4.25.6
// source: options.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "psrpc";

/** RPC types */
export const Routing = {
  /** QUEUE - Servers will join a queue, and only one will receive each request */
  QUEUE: 0,
  /** AFFINITY - Servers will implement an affinity function for handler selection */
  AFFINITY: 1,
  /** MULTI - Every server will respond to every request (for subscriptions, all clients will receive every message) */
  MULTI: 2,
  UNRECOGNIZED: -1,
} as const;

export type Routing = typeof Routing[keyof typeof Routing];

export namespace Routing {
  export type QUEUE = typeof Routing.QUEUE;
  export type AFFINITY = typeof Routing.AFFINITY;
  export type MULTI = typeof Routing.MULTI;
  export type UNRECOGNIZED = typeof Routing.UNRECOGNIZED;
}

export function routingFromJSON(object: any): Routing {
  switch (object) {
    case 0:
    case "QUEUE":
      return Routing.QUEUE;
    case 1:
    case "AFFINITY":
      return Routing.AFFINITY;
    case 2:
    case "MULTI":
      return Routing.MULTI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Routing.UNRECOGNIZED;
  }
}

export function routingToJSON(object: Routing): string {
  switch (object) {
    case Routing.QUEUE:
      return "QUEUE";
    case Routing.AFFINITY:
      return "AFFINITY";
    case Routing.MULTI:
      return "MULTI";
    case Routing.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Options {
  /** This method is a pub/sub. */
  subscription: boolean;
  /** This method uses topics. */
  topics: boolean;
  topicParams:
    | TopicParamOptions
    | undefined;
  /** The method uses bidirectional streaming. */
  stream: boolean;
  /** RPC type */
  type: Routing;
  /**
   * For RPCs, each client request will receive a response from every server.
   * For subscriptions, every client will receive every update.
   */
  multi?:
    | boolean
    | undefined;
  /** Your service will supply an affinity function for handler selection. */
  affinityFunc?:
    | boolean
    | undefined;
  /** Requests load balancing is provided by a pub/sub server queue */
  queue?: boolean | undefined;
}

export interface TopicParamOptions {
  /** The rpc can be registered/deregistered atomically with other group members */
  group: string;
  /** The topic is composed of one or more string-like parameters. */
  names: string[];
  /** The topic parameters have associated string-like type parameters */
  typed: boolean;
  /** At most one server will be registered for each topic */
  singleServer: boolean;
}

function createBaseOptions(): Options {
  return {
    subscription: false,
    topics: false,
    topicParams: undefined,
    stream: false,
    type: 0,
    multi: undefined,
    affinityFunc: undefined,
    queue: undefined,
  };
}

export const Options: MessageFns<Options> = {
  encode(message: Options, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscription !== false) {
      writer.uint32(8).bool(message.subscription);
    }
    if (message.topics !== false) {
      writer.uint32(16).bool(message.topics);
    }
    if (message.topicParams !== undefined) {
      TopicParamOptions.encode(message.topicParams, writer.uint32(26).fork()).join();
    }
    if (message.stream !== false) {
      writer.uint32(32).bool(message.stream);
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    if (message.multi !== undefined) {
      writer.uint32(40).bool(message.multi);
    }
    if (message.affinityFunc !== undefined) {
      writer.uint32(48).bool(message.affinityFunc);
    }
    if (message.queue !== undefined) {
      writer.uint32(56).bool(message.queue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Options {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.subscription = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topics = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.topicParams = TopicParamOptions.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.stream = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.multi = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.affinityFunc = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.queue = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Options {
    return {
      subscription: isSet(object.subscription) ? globalThis.Boolean(object.subscription) : false,
      topics: isSet(object.topics) ? globalThis.Boolean(object.topics) : false,
      topicParams: isSet(object.topicParams) ? TopicParamOptions.fromJSON(object.topicParams) : undefined,
      stream: isSet(object.stream) ? globalThis.Boolean(object.stream) : false,
      type: isSet(object.type) ? routingFromJSON(object.type) : 0,
      multi: isSet(object.multi) ? globalThis.Boolean(object.multi) : undefined,
      affinityFunc: isSet(object.affinityFunc) ? globalThis.Boolean(object.affinityFunc) : undefined,
      queue: isSet(object.queue) ? globalThis.Boolean(object.queue) : undefined,
    };
  },

  toJSON(message: Options): unknown {
    const obj: any = {};
    if (message.subscription !== false) {
      obj.subscription = message.subscription;
    }
    if (message.topics !== false) {
      obj.topics = message.topics;
    }
    if (message.topicParams !== undefined) {
      obj.topicParams = TopicParamOptions.toJSON(message.topicParams);
    }
    if (message.stream !== false) {
      obj.stream = message.stream;
    }
    if (message.type !== 0) {
      obj.type = routingToJSON(message.type);
    }
    if (message.multi !== undefined) {
      obj.multi = message.multi;
    }
    if (message.affinityFunc !== undefined) {
      obj.affinityFunc = message.affinityFunc;
    }
    if (message.queue !== undefined) {
      obj.queue = message.queue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Options>, I>>(base?: I): Options {
    return Options.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Options>, I>>(object: I): Options {
    const message = createBaseOptions();
    message.subscription = object.subscription ?? false;
    message.topics = object.topics ?? false;
    message.topicParams = (object.topicParams !== undefined && object.topicParams !== null)
      ? TopicParamOptions.fromPartial(object.topicParams)
      : undefined;
    message.stream = object.stream ?? false;
    message.type = object.type ?? 0;
    message.multi = object.multi ?? undefined;
    message.affinityFunc = object.affinityFunc ?? undefined;
    message.queue = object.queue ?? undefined;
    return message;
  },
};

function createBaseTopicParamOptions(): TopicParamOptions {
  return { group: "", names: [], typed: false, singleServer: false };
}

export const TopicParamOptions: MessageFns<TopicParamOptions> = {
  encode(message: TopicParamOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    for (const v of message.names) {
      writer.uint32(18).string(v!);
    }
    if (message.typed !== false) {
      writer.uint32(24).bool(message.typed);
    }
    if (message.singleServer !== false) {
      writer.uint32(32).bool(message.singleServer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicParamOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicParamOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.names.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.typed = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.singleServer = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicParamOptions {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
      typed: isSet(object.typed) ? globalThis.Boolean(object.typed) : false,
      singleServer: isSet(object.singleServer) ? globalThis.Boolean(object.singleServer) : false,
    };
  },

  toJSON(message: TopicParamOptions): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.names?.length) {
      obj.names = message.names;
    }
    if (message.typed !== false) {
      obj.typed = message.typed;
    }
    if (message.singleServer !== false) {
      obj.singleServer = message.singleServer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicParamOptions>, I>>(base?: I): TopicParamOptions {
    return TopicParamOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicParamOptions>, I>>(object: I): TopicParamOptions {
    const message = createBaseTopicParamOptions();
    message.group = object.group ?? "";
    message.names = object.names?.map((e) => e) || [];
    message.typed = object.typed ?? false;
    message.singleServer = object.singleServer ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
